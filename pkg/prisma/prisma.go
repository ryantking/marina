// Code generated by Prisma CLI (https://github.com/prisma/prisma). DO NOT EDIT.

package prisma

import (
	"context"
	"errors"

	"github.com/prisma/prisma-client-lib-go"

	"github.com/machinebox/graphql"
)

var ErrNoResult = errors.New("query returned no result")

func Str(v string) *string { return &v }
func Int32(v int32) *int32 { return &v }
func Bool(v bool) *bool    { return &v }

type BatchPayloadExec struct {
	exec *prisma.BatchPayloadExec
}

func (exec *BatchPayloadExec) Exec(ctx context.Context) (BatchPayload, error) {
	bp, err := exec.exec.Exec(ctx)
	return BatchPayload(bp), err
}

type BatchPayload struct {
	Count int64 `json:"count"`
}

type Aggregate struct {
	Count int64 `json:"count"`
}

type Client struct {
	Client *prisma.Client
}

type Options struct {
	Endpoint string
	Secret   string
}

func New(options *Options, opts ...graphql.ClientOption) *Client {
	endpoint := DefaultEndpoint
	secret := Secret
	if options != nil {
		endpoint = options.Endpoint
		secret = options.Secret
	}
	return &Client{
		Client: prisma.New(endpoint, secret, opts...),
	}
}

func (client *Client) GraphQL(ctx context.Context, query string, variables map[string]interface{}) (map[string]interface{}, error) {
	return client.Client.GraphQL(ctx, query, variables)
}

var DefaultEndpoint = "http://localhost:4466/marina/dev"
var Secret = ""

func (client *Client) Blob(params BlobWhereUniqueInput) *BlobExec {
	ret := client.Client.GetOne(
		nil,
		params,
		[2]string{"BlobWhereUniqueInput!", "Blob"},
		"blob",
		[]string{"id", "createdAt", "updatedAt", "digest"})

	return &BlobExec{ret}
}

type BlobsParams struct {
	Where   *BlobWhereInput   `json:"where,omitempty"`
	OrderBy *BlobOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32            `json:"skip,omitempty"`
	After   *string           `json:"after,omitempty"`
	Before  *string           `json:"before,omitempty"`
	First   *int32            `json:"first,omitempty"`
	Last    *int32            `json:"last,omitempty"`
}

func (client *Client) Blobs(params *BlobsParams) *BlobExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"BlobWhereInput", "BlobOrderByInput", "Blob"},
		"blobs",
		[]string{"id", "createdAt", "updatedAt", "digest"})

	return &BlobExecArray{ret}
}

type BlobsConnectionParams struct {
	Where   *BlobWhereInput   `json:"where,omitempty"`
	OrderBy *BlobOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32            `json:"skip,omitempty"`
	After   *string           `json:"after,omitempty"`
	Before  *string           `json:"before,omitempty"`
	First   *int32            `json:"first,omitempty"`
	Last    *int32            `json:"last,omitempty"`
}

func (client *Client) BlobsConnection(params *BlobsConnectionParams) BlobConnectionExec {
	panic("not implemented")
}

func (client *Client) Chunk(params ChunkWhereUniqueInput) *ChunkExec {
	ret := client.Client.GetOne(
		nil,
		params,
		[2]string{"ChunkWhereUniqueInput!", "Chunk"},
		"chunk",
		[]string{"id", "createdAt", "updatedAt", "rangeStart", "rangeEnd"})

	return &ChunkExec{ret}
}

type ChunksParams struct {
	Where   *ChunkWhereInput   `json:"where,omitempty"`
	OrderBy *ChunkOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32             `json:"skip,omitempty"`
	After   *string            `json:"after,omitempty"`
	Before  *string            `json:"before,omitempty"`
	First   *int32             `json:"first,omitempty"`
	Last    *int32             `json:"last,omitempty"`
}

func (client *Client) Chunks(params *ChunksParams) *ChunkExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"ChunkWhereInput", "ChunkOrderByInput", "Chunk"},
		"chunks",
		[]string{"id", "createdAt", "updatedAt", "rangeStart", "rangeEnd"})

	return &ChunkExecArray{ret}
}

type ChunksConnectionParams struct {
	Where   *ChunkWhereInput   `json:"where,omitempty"`
	OrderBy *ChunkOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32             `json:"skip,omitempty"`
	After   *string            `json:"after,omitempty"`
	Before  *string            `json:"before,omitempty"`
	First   *int32             `json:"first,omitempty"`
	Last    *int32             `json:"last,omitempty"`
}

func (client *Client) ChunksConnection(params *ChunksConnectionParams) ChunkConnectionExec {
	panic("not implemented")
}

func (client *Client) Image(params ImageWhereUniqueInput) *ImageExec {
	ret := client.Client.GetOne(
		nil,
		params,
		[2]string{"ImageWhereUniqueInput!", "Image"},
		"image",
		[]string{"id", "createdAt", "updatedAt", "digest", "manifest", "manifest_type"})

	return &ImageExec{ret}
}

type ImagesParams struct {
	Where   *ImageWhereInput   `json:"where,omitempty"`
	OrderBy *ImageOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32             `json:"skip,omitempty"`
	After   *string            `json:"after,omitempty"`
	Before  *string            `json:"before,omitempty"`
	First   *int32             `json:"first,omitempty"`
	Last    *int32             `json:"last,omitempty"`
}

func (client *Client) Images(params *ImagesParams) *ImageExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"ImageWhereInput", "ImageOrderByInput", "Image"},
		"images",
		[]string{"id", "createdAt", "updatedAt", "digest", "manifest", "manifest_type"})

	return &ImageExecArray{ret}
}

type ImagesConnectionParams struct {
	Where   *ImageWhereInput   `json:"where,omitempty"`
	OrderBy *ImageOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32             `json:"skip,omitempty"`
	After   *string            `json:"after,omitempty"`
	Before  *string            `json:"before,omitempty"`
	First   *int32             `json:"first,omitempty"`
	Last    *int32             `json:"last,omitempty"`
}

func (client *Client) ImagesConnection(params *ImagesConnectionParams) ImageConnectionExec {
	panic("not implemented")
}

func (client *Client) Organization(params OrganizationWhereUniqueInput) *OrganizationExec {
	ret := client.Client.GetOne(
		nil,
		params,
		[2]string{"OrganizationWhereUniqueInput!", "Organization"},
		"organization",
		[]string{"id", "createdAt", "updatedAt", "name"})

	return &OrganizationExec{ret}
}

type OrganizationsParams struct {
	Where   *OrganizationWhereInput   `json:"where,omitempty"`
	OrderBy *OrganizationOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32                    `json:"skip,omitempty"`
	After   *string                   `json:"after,omitempty"`
	Before  *string                   `json:"before,omitempty"`
	First   *int32                    `json:"first,omitempty"`
	Last    *int32                    `json:"last,omitempty"`
}

func (client *Client) Organizations(params *OrganizationsParams) *OrganizationExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"OrganizationWhereInput", "OrganizationOrderByInput", "Organization"},
		"organizations",
		[]string{"id", "createdAt", "updatedAt", "name"})

	return &OrganizationExecArray{ret}
}

type OrganizationsConnectionParams struct {
	Where   *OrganizationWhereInput   `json:"where,omitempty"`
	OrderBy *OrganizationOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32                    `json:"skip,omitempty"`
	After   *string                   `json:"after,omitempty"`
	Before  *string                   `json:"before,omitempty"`
	First   *int32                    `json:"first,omitempty"`
	Last    *int32                    `json:"last,omitempty"`
}

func (client *Client) OrganizationsConnection(params *OrganizationsConnectionParams) OrganizationConnectionExec {
	panic("not implemented")
}

func (client *Client) Repository(params RepositoryWhereUniqueInput) *RepositoryExec {
	ret := client.Client.GetOne(
		nil,
		params,
		[2]string{"RepositoryWhereUniqueInput!", "Repository"},
		"repository",
		[]string{"id", "createdAt", "updatedAt", "name"})

	return &RepositoryExec{ret}
}

type RepositoriesParams struct {
	Where   *RepositoryWhereInput   `json:"where,omitempty"`
	OrderBy *RepositoryOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32                  `json:"skip,omitempty"`
	After   *string                 `json:"after,omitempty"`
	Before  *string                 `json:"before,omitempty"`
	First   *int32                  `json:"first,omitempty"`
	Last    *int32                  `json:"last,omitempty"`
}

func (client *Client) Repositories(params *RepositoriesParams) *RepositoryExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"RepositoryWhereInput", "RepositoryOrderByInput", "Repository"},
		"repositories",
		[]string{"id", "createdAt", "updatedAt", "name"})

	return &RepositoryExecArray{ret}
}

type RepositoriesConnectionParams struct {
	Where   *RepositoryWhereInput   `json:"where,omitempty"`
	OrderBy *RepositoryOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32                  `json:"skip,omitempty"`
	After   *string                 `json:"after,omitempty"`
	Before  *string                 `json:"before,omitempty"`
	First   *int32                  `json:"first,omitempty"`
	Last    *int32                  `json:"last,omitempty"`
}

func (client *Client) RepositoriesConnection(params *RepositoriesConnectionParams) RepositoryConnectionExec {
	panic("not implemented")
}

func (client *Client) Tag(params TagWhereUniqueInput) *TagExec {
	ret := client.Client.GetOne(
		nil,
		params,
		[2]string{"TagWhereUniqueInput!", "Tag"},
		"tag",
		[]string{"id", "createdAt", "updatedAt"})

	return &TagExec{ret}
}

type TagsParams struct {
	Where   *TagWhereInput   `json:"where,omitempty"`
	OrderBy *TagOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32           `json:"skip,omitempty"`
	After   *string          `json:"after,omitempty"`
	Before  *string          `json:"before,omitempty"`
	First   *int32           `json:"first,omitempty"`
	Last    *int32           `json:"last,omitempty"`
}

func (client *Client) Tags(params *TagsParams) *TagExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"TagWhereInput", "TagOrderByInput", "Tag"},
		"tags",
		[]string{"id", "createdAt", "updatedAt"})

	return &TagExecArray{ret}
}

type TagsConnectionParams struct {
	Where   *TagWhereInput   `json:"where,omitempty"`
	OrderBy *TagOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32           `json:"skip,omitempty"`
	After   *string          `json:"after,omitempty"`
	Before  *string          `json:"before,omitempty"`
	First   *int32           `json:"first,omitempty"`
	Last    *int32           `json:"last,omitempty"`
}

func (client *Client) TagsConnection(params *TagsConnectionParams) TagConnectionExec {
	panic("not implemented")
}

func (client *Client) Upload(params UploadWhereUniqueInput) *UploadExec {
	ret := client.Client.GetOne(
		nil,
		params,
		[2]string{"UploadWhereUniqueInput!", "Upload"},
		"upload",
		[]string{"id", "createdAt", "updatedAt", "uuid", "done"})

	return &UploadExec{ret}
}

type UploadsParams struct {
	Where   *UploadWhereInput   `json:"where,omitempty"`
	OrderBy *UploadOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32              `json:"skip,omitempty"`
	After   *string             `json:"after,omitempty"`
	Before  *string             `json:"before,omitempty"`
	First   *int32              `json:"first,omitempty"`
	Last    *int32              `json:"last,omitempty"`
}

func (client *Client) Uploads(params *UploadsParams) *UploadExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"UploadWhereInput", "UploadOrderByInput", "Upload"},
		"uploads",
		[]string{"id", "createdAt", "updatedAt", "uuid", "done"})

	return &UploadExecArray{ret}
}

type UploadsConnectionParams struct {
	Where   *UploadWhereInput   `json:"where,omitempty"`
	OrderBy *UploadOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32              `json:"skip,omitempty"`
	After   *string             `json:"after,omitempty"`
	Before  *string             `json:"before,omitempty"`
	First   *int32              `json:"first,omitempty"`
	Last    *int32              `json:"last,omitempty"`
}

func (client *Client) UploadsConnection(params *UploadsConnectionParams) UploadConnectionExec {
	panic("not implemented")
}

func (client *Client) CreateBlob(params BlobCreateInput) *BlobExec {
	ret := client.Client.Create(
		params,
		[2]string{"BlobCreateInput!", "Blob"},
		"createBlob",
		[]string{"id", "createdAt", "updatedAt", "digest"})

	return &BlobExec{ret}
}

type BlobUpdateParams struct {
	Data  BlobUpdateInput      `json:"data"`
	Where BlobWhereUniqueInput `json:"where"`
}

func (client *Client) UpdateBlob(params BlobUpdateParams) *BlobExec {
	ret := client.Client.Update(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[3]string{"BlobUpdateInput!", "BlobWhereUniqueInput!", "Blob"},
		"updateBlob",
		[]string{"id", "createdAt", "updatedAt", "digest"})

	return &BlobExec{ret}
}

type BlobUpdateManyParams struct {
	Data  BlobUpdateManyMutationInput `json:"data"`
	Where *BlobWhereInput             `json:"where,omitempty"`
}

func (client *Client) UpdateManyBlobs(params BlobUpdateManyParams) *BatchPayloadExec {
	exec := client.Client.UpdateMany(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[2]string{"BlobUpdateManyMutationInput!", "BlobWhereInput"},
		"updateManyBlobs")
	return &BatchPayloadExec{exec}
}

type BlobUpsertParams struct {
	Where  BlobWhereUniqueInput `json:"where"`
	Create BlobCreateInput      `json:"create"`
	Update BlobUpdateInput      `json:"update"`
}

func (client *Client) UpsertBlob(params BlobUpsertParams) *BlobExec {
	uparams := &prisma.UpsertParams{
		Where:  params.Where,
		Create: params.Create,
		Update: params.Update,
	}
	ret := client.Client.Upsert(
		uparams,
		[4]string{"BlobWhereUniqueInput!", "BlobCreateInput!", "BlobUpdateInput!", "Blob"},
		"upsertBlob",
		[]string{"id", "createdAt", "updatedAt", "digest"})

	return &BlobExec{ret}
}

func (client *Client) DeleteBlob(params BlobWhereUniqueInput) *BlobExec {
	ret := client.Client.Delete(
		params,
		[2]string{"BlobWhereUniqueInput!", "Blob"},
		"deleteBlob",
		[]string{"id", "createdAt", "updatedAt", "digest"})

	return &BlobExec{ret}
}

func (client *Client) DeleteManyBlobs(params *BlobWhereInput) *BatchPayloadExec {
	exec := client.Client.DeleteMany(params, "BlobWhereInput", "deleteManyBlobs")
	return &BatchPayloadExec{exec}
}

func (client *Client) CreateChunk(params ChunkCreateInput) *ChunkExec {
	ret := client.Client.Create(
		params,
		[2]string{"ChunkCreateInput!", "Chunk"},
		"createChunk",
		[]string{"id", "createdAt", "updatedAt", "rangeStart", "rangeEnd"})

	return &ChunkExec{ret}
}

type ChunkUpdateParams struct {
	Data  ChunkUpdateInput      `json:"data"`
	Where ChunkWhereUniqueInput `json:"where"`
}

func (client *Client) UpdateChunk(params ChunkUpdateParams) *ChunkExec {
	ret := client.Client.Update(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[3]string{"ChunkUpdateInput!", "ChunkWhereUniqueInput!", "Chunk"},
		"updateChunk",
		[]string{"id", "createdAt", "updatedAt", "rangeStart", "rangeEnd"})

	return &ChunkExec{ret}
}

type ChunkUpdateManyParams struct {
	Data  ChunkUpdateManyMutationInput `json:"data"`
	Where *ChunkWhereInput             `json:"where,omitempty"`
}

func (client *Client) UpdateManyChunks(params ChunkUpdateManyParams) *BatchPayloadExec {
	exec := client.Client.UpdateMany(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[2]string{"ChunkUpdateManyMutationInput!", "ChunkWhereInput"},
		"updateManyChunks")
	return &BatchPayloadExec{exec}
}

type ChunkUpsertParams struct {
	Where  ChunkWhereUniqueInput `json:"where"`
	Create ChunkCreateInput      `json:"create"`
	Update ChunkUpdateInput      `json:"update"`
}

func (client *Client) UpsertChunk(params ChunkUpsertParams) *ChunkExec {
	uparams := &prisma.UpsertParams{
		Where:  params.Where,
		Create: params.Create,
		Update: params.Update,
	}
	ret := client.Client.Upsert(
		uparams,
		[4]string{"ChunkWhereUniqueInput!", "ChunkCreateInput!", "ChunkUpdateInput!", "Chunk"},
		"upsertChunk",
		[]string{"id", "createdAt", "updatedAt", "rangeStart", "rangeEnd"})

	return &ChunkExec{ret}
}

func (client *Client) DeleteChunk(params ChunkWhereUniqueInput) *ChunkExec {
	ret := client.Client.Delete(
		params,
		[2]string{"ChunkWhereUniqueInput!", "Chunk"},
		"deleteChunk",
		[]string{"id", "createdAt", "updatedAt", "rangeStart", "rangeEnd"})

	return &ChunkExec{ret}
}

func (client *Client) DeleteManyChunks(params *ChunkWhereInput) *BatchPayloadExec {
	exec := client.Client.DeleteMany(params, "ChunkWhereInput", "deleteManyChunks")
	return &BatchPayloadExec{exec}
}

func (client *Client) CreateImage(params ImageCreateInput) *ImageExec {
	ret := client.Client.Create(
		params,
		[2]string{"ImageCreateInput!", "Image"},
		"createImage",
		[]string{"id", "createdAt", "updatedAt", "digest", "manifest", "manifest_type"})

	return &ImageExec{ret}
}

type ImageUpdateParams struct {
	Data  ImageUpdateInput      `json:"data"`
	Where ImageWhereUniqueInput `json:"where"`
}

func (client *Client) UpdateImage(params ImageUpdateParams) *ImageExec {
	ret := client.Client.Update(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[3]string{"ImageUpdateInput!", "ImageWhereUniqueInput!", "Image"},
		"updateImage",
		[]string{"id", "createdAt", "updatedAt", "digest", "manifest", "manifest_type"})

	return &ImageExec{ret}
}

type ImageUpdateManyParams struct {
	Data  ImageUpdateManyMutationInput `json:"data"`
	Where *ImageWhereInput             `json:"where,omitempty"`
}

func (client *Client) UpdateManyImages(params ImageUpdateManyParams) *BatchPayloadExec {
	exec := client.Client.UpdateMany(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[2]string{"ImageUpdateManyMutationInput!", "ImageWhereInput"},
		"updateManyImages")
	return &BatchPayloadExec{exec}
}

type ImageUpsertParams struct {
	Where  ImageWhereUniqueInput `json:"where"`
	Create ImageCreateInput      `json:"create"`
	Update ImageUpdateInput      `json:"update"`
}

func (client *Client) UpsertImage(params ImageUpsertParams) *ImageExec {
	uparams := &prisma.UpsertParams{
		Where:  params.Where,
		Create: params.Create,
		Update: params.Update,
	}
	ret := client.Client.Upsert(
		uparams,
		[4]string{"ImageWhereUniqueInput!", "ImageCreateInput!", "ImageUpdateInput!", "Image"},
		"upsertImage",
		[]string{"id", "createdAt", "updatedAt", "digest", "manifest", "manifest_type"})

	return &ImageExec{ret}
}

func (client *Client) DeleteImage(params ImageWhereUniqueInput) *ImageExec {
	ret := client.Client.Delete(
		params,
		[2]string{"ImageWhereUniqueInput!", "Image"},
		"deleteImage",
		[]string{"id", "createdAt", "updatedAt", "digest", "manifest", "manifest_type"})

	return &ImageExec{ret}
}

func (client *Client) DeleteManyImages(params *ImageWhereInput) *BatchPayloadExec {
	exec := client.Client.DeleteMany(params, "ImageWhereInput", "deleteManyImages")
	return &BatchPayloadExec{exec}
}

func (client *Client) CreateOrganization(params OrganizationCreateInput) *OrganizationExec {
	ret := client.Client.Create(
		params,
		[2]string{"OrganizationCreateInput!", "Organization"},
		"createOrganization",
		[]string{"id", "createdAt", "updatedAt", "name"})

	return &OrganizationExec{ret}
}

type OrganizationUpdateParams struct {
	Data  OrganizationUpdateInput      `json:"data"`
	Where OrganizationWhereUniqueInput `json:"where"`
}

func (client *Client) UpdateOrganization(params OrganizationUpdateParams) *OrganizationExec {
	ret := client.Client.Update(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[3]string{"OrganizationUpdateInput!", "OrganizationWhereUniqueInput!", "Organization"},
		"updateOrganization",
		[]string{"id", "createdAt", "updatedAt", "name"})

	return &OrganizationExec{ret}
}

type OrganizationUpdateManyParams struct {
	Data  OrganizationUpdateManyMutationInput `json:"data"`
	Where *OrganizationWhereInput             `json:"where,omitempty"`
}

func (client *Client) UpdateManyOrganizations(params OrganizationUpdateManyParams) *BatchPayloadExec {
	exec := client.Client.UpdateMany(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[2]string{"OrganizationUpdateManyMutationInput!", "OrganizationWhereInput"},
		"updateManyOrganizations")
	return &BatchPayloadExec{exec}
}

type OrganizationUpsertParams struct {
	Where  OrganizationWhereUniqueInput `json:"where"`
	Create OrganizationCreateInput      `json:"create"`
	Update OrganizationUpdateInput      `json:"update"`
}

func (client *Client) UpsertOrganization(params OrganizationUpsertParams) *OrganizationExec {
	uparams := &prisma.UpsertParams{
		Where:  params.Where,
		Create: params.Create,
		Update: params.Update,
	}
	ret := client.Client.Upsert(
		uparams,
		[4]string{"OrganizationWhereUniqueInput!", "OrganizationCreateInput!", "OrganizationUpdateInput!", "Organization"},
		"upsertOrganization",
		[]string{"id", "createdAt", "updatedAt", "name"})

	return &OrganizationExec{ret}
}

func (client *Client) DeleteOrganization(params OrganizationWhereUniqueInput) *OrganizationExec {
	ret := client.Client.Delete(
		params,
		[2]string{"OrganizationWhereUniqueInput!", "Organization"},
		"deleteOrganization",
		[]string{"id", "createdAt", "updatedAt", "name"})

	return &OrganizationExec{ret}
}

func (client *Client) DeleteManyOrganizations(params *OrganizationWhereInput) *BatchPayloadExec {
	exec := client.Client.DeleteMany(params, "OrganizationWhereInput", "deleteManyOrganizations")
	return &BatchPayloadExec{exec}
}

func (client *Client) CreateRepository(params RepositoryCreateInput) *RepositoryExec {
	ret := client.Client.Create(
		params,
		[2]string{"RepositoryCreateInput!", "Repository"},
		"createRepository",
		[]string{"id", "createdAt", "updatedAt", "name"})

	return &RepositoryExec{ret}
}

type RepositoryUpdateParams struct {
	Data  RepositoryUpdateInput      `json:"data"`
	Where RepositoryWhereUniqueInput `json:"where"`
}

func (client *Client) UpdateRepository(params RepositoryUpdateParams) *RepositoryExec {
	ret := client.Client.Update(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[3]string{"RepositoryUpdateInput!", "RepositoryWhereUniqueInput!", "Repository"},
		"updateRepository",
		[]string{"id", "createdAt", "updatedAt", "name"})

	return &RepositoryExec{ret}
}

type RepositoryUpdateManyParams struct {
	Data  RepositoryUpdateManyMutationInput `json:"data"`
	Where *RepositoryWhereInput             `json:"where,omitempty"`
}

func (client *Client) UpdateManyRepositories(params RepositoryUpdateManyParams) *BatchPayloadExec {
	exec := client.Client.UpdateMany(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[2]string{"RepositoryUpdateManyMutationInput!", "RepositoryWhereInput"},
		"updateManyRepositories")
	return &BatchPayloadExec{exec}
}

type RepositoryUpsertParams struct {
	Where  RepositoryWhereUniqueInput `json:"where"`
	Create RepositoryCreateInput      `json:"create"`
	Update RepositoryUpdateInput      `json:"update"`
}

func (client *Client) UpsertRepository(params RepositoryUpsertParams) *RepositoryExec {
	uparams := &prisma.UpsertParams{
		Where:  params.Where,
		Create: params.Create,
		Update: params.Update,
	}
	ret := client.Client.Upsert(
		uparams,
		[4]string{"RepositoryWhereUniqueInput!", "RepositoryCreateInput!", "RepositoryUpdateInput!", "Repository"},
		"upsertRepository",
		[]string{"id", "createdAt", "updatedAt", "name"})

	return &RepositoryExec{ret}
}

func (client *Client) DeleteRepository(params RepositoryWhereUniqueInput) *RepositoryExec {
	ret := client.Client.Delete(
		params,
		[2]string{"RepositoryWhereUniqueInput!", "Repository"},
		"deleteRepository",
		[]string{"id", "createdAt", "updatedAt", "name"})

	return &RepositoryExec{ret}
}

func (client *Client) DeleteManyRepositories(params *RepositoryWhereInput) *BatchPayloadExec {
	exec := client.Client.DeleteMany(params, "RepositoryWhereInput", "deleteManyRepositories")
	return &BatchPayloadExec{exec}
}

func (client *Client) CreateTag(params TagCreateInput) *TagExec {
	ret := client.Client.Create(
		params,
		[2]string{"TagCreateInput!", "Tag"},
		"createTag",
		[]string{"id", "createdAt", "updatedAt"})

	return &TagExec{ret}
}

type TagUpdateParams struct {
	Data  TagUpdateInput      `json:"data"`
	Where TagWhereUniqueInput `json:"where"`
}

func (client *Client) UpdateTag(params TagUpdateParams) *TagExec {
	ret := client.Client.Update(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[3]string{"TagUpdateInput!", "TagWhereUniqueInput!", "Tag"},
		"updateTag",
		[]string{"id", "createdAt", "updatedAt"})

	return &TagExec{ret}
}

type TagUpsertParams struct {
	Where  TagWhereUniqueInput `json:"where"`
	Create TagCreateInput      `json:"create"`
	Update TagUpdateInput      `json:"update"`
}

func (client *Client) UpsertTag(params TagUpsertParams) *TagExec {
	uparams := &prisma.UpsertParams{
		Where:  params.Where,
		Create: params.Create,
		Update: params.Update,
	}
	ret := client.Client.Upsert(
		uparams,
		[4]string{"TagWhereUniqueInput!", "TagCreateInput!", "TagUpdateInput!", "Tag"},
		"upsertTag",
		[]string{"id", "createdAt", "updatedAt"})

	return &TagExec{ret}
}

func (client *Client) DeleteTag(params TagWhereUniqueInput) *TagExec {
	ret := client.Client.Delete(
		params,
		[2]string{"TagWhereUniqueInput!", "Tag"},
		"deleteTag",
		[]string{"id", "createdAt", "updatedAt"})

	return &TagExec{ret}
}

func (client *Client) DeleteManyTags(params *TagWhereInput) *BatchPayloadExec {
	exec := client.Client.DeleteMany(params, "TagWhereInput", "deleteManyTags")
	return &BatchPayloadExec{exec}
}

func (client *Client) CreateUpload(params UploadCreateInput) *UploadExec {
	ret := client.Client.Create(
		params,
		[2]string{"UploadCreateInput!", "Upload"},
		"createUpload",
		[]string{"id", "createdAt", "updatedAt", "uuid", "done"})

	return &UploadExec{ret}
}

type UploadUpdateParams struct {
	Data  UploadUpdateInput      `json:"data"`
	Where UploadWhereUniqueInput `json:"where"`
}

func (client *Client) UpdateUpload(params UploadUpdateParams) *UploadExec {
	ret := client.Client.Update(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[3]string{"UploadUpdateInput!", "UploadWhereUniqueInput!", "Upload"},
		"updateUpload",
		[]string{"id", "createdAt", "updatedAt", "uuid", "done"})

	return &UploadExec{ret}
}

type UploadUpdateManyParams struct {
	Data  UploadUpdateManyMutationInput `json:"data"`
	Where *UploadWhereInput             `json:"where,omitempty"`
}

func (client *Client) UpdateManyUploads(params UploadUpdateManyParams) *BatchPayloadExec {
	exec := client.Client.UpdateMany(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[2]string{"UploadUpdateManyMutationInput!", "UploadWhereInput"},
		"updateManyUploads")
	return &BatchPayloadExec{exec}
}

type UploadUpsertParams struct {
	Where  UploadWhereUniqueInput `json:"where"`
	Create UploadCreateInput      `json:"create"`
	Update UploadUpdateInput      `json:"update"`
}

func (client *Client) UpsertUpload(params UploadUpsertParams) *UploadExec {
	uparams := &prisma.UpsertParams{
		Where:  params.Where,
		Create: params.Create,
		Update: params.Update,
	}
	ret := client.Client.Upsert(
		uparams,
		[4]string{"UploadWhereUniqueInput!", "UploadCreateInput!", "UploadUpdateInput!", "Upload"},
		"upsertUpload",
		[]string{"id", "createdAt", "updatedAt", "uuid", "done"})

	return &UploadExec{ret}
}

func (client *Client) DeleteUpload(params UploadWhereUniqueInput) *UploadExec {
	ret := client.Client.Delete(
		params,
		[2]string{"UploadWhereUniqueInput!", "Upload"},
		"deleteUpload",
		[]string{"id", "createdAt", "updatedAt", "uuid", "done"})

	return &UploadExec{ret}
}

func (client *Client) DeleteManyUploads(params *UploadWhereInput) *BatchPayloadExec {
	exec := client.Client.DeleteMany(params, "UploadWhereInput", "deleteManyUploads")
	return &BatchPayloadExec{exec}
}

type RepositoryOrderByInput string

const (
	RepositoryOrderByInputIDAsc         RepositoryOrderByInput = "id_ASC"
	RepositoryOrderByInputIDDesc        RepositoryOrderByInput = "id_DESC"
	RepositoryOrderByInputCreatedAtAsc  RepositoryOrderByInput = "createdAt_ASC"
	RepositoryOrderByInputCreatedAtDesc RepositoryOrderByInput = "createdAt_DESC"
	RepositoryOrderByInputUpdatedAtAsc  RepositoryOrderByInput = "updatedAt_ASC"
	RepositoryOrderByInputUpdatedAtDesc RepositoryOrderByInput = "updatedAt_DESC"
	RepositoryOrderByInputNameAsc       RepositoryOrderByInput = "name_ASC"
	RepositoryOrderByInputNameDesc      RepositoryOrderByInput = "name_DESC"
)

type BlobOrderByInput string

const (
	BlobOrderByInputIDAsc         BlobOrderByInput = "id_ASC"
	BlobOrderByInputIDDesc        BlobOrderByInput = "id_DESC"
	BlobOrderByInputCreatedAtAsc  BlobOrderByInput = "createdAt_ASC"
	BlobOrderByInputCreatedAtDesc BlobOrderByInput = "createdAt_DESC"
	BlobOrderByInputUpdatedAtAsc  BlobOrderByInput = "updatedAt_ASC"
	BlobOrderByInputUpdatedAtDesc BlobOrderByInput = "updatedAt_DESC"
	BlobOrderByInputDigestAsc     BlobOrderByInput = "digest_ASC"
	BlobOrderByInputDigestDesc    BlobOrderByInput = "digest_DESC"
)

type ImageOrderByInput string

const (
	ImageOrderByInputIDAsc            ImageOrderByInput = "id_ASC"
	ImageOrderByInputIDDesc           ImageOrderByInput = "id_DESC"
	ImageOrderByInputCreatedAtAsc     ImageOrderByInput = "createdAt_ASC"
	ImageOrderByInputCreatedAtDesc    ImageOrderByInput = "createdAt_DESC"
	ImageOrderByInputUpdatedAtAsc     ImageOrderByInput = "updatedAt_ASC"
	ImageOrderByInputUpdatedAtDesc    ImageOrderByInput = "updatedAt_DESC"
	ImageOrderByInputDigestAsc        ImageOrderByInput = "digest_ASC"
	ImageOrderByInputDigestDesc       ImageOrderByInput = "digest_DESC"
	ImageOrderByInputManifestAsc      ImageOrderByInput = "manifest_ASC"
	ImageOrderByInputManifestDesc     ImageOrderByInput = "manifest_DESC"
	ImageOrderByInputManifestTypeAsc  ImageOrderByInput = "manifest_type_ASC"
	ImageOrderByInputManifestTypeDesc ImageOrderByInput = "manifest_type_DESC"
)

type TagOrderByInput string

const (
	TagOrderByInputIDAsc         TagOrderByInput = "id_ASC"
	TagOrderByInputIDDesc        TagOrderByInput = "id_DESC"
	TagOrderByInputCreatedAtAsc  TagOrderByInput = "createdAt_ASC"
	TagOrderByInputCreatedAtDesc TagOrderByInput = "createdAt_DESC"
	TagOrderByInputUpdatedAtAsc  TagOrderByInput = "updatedAt_ASC"
	TagOrderByInputUpdatedAtDesc TagOrderByInput = "updatedAt_DESC"
)

type ChunkOrderByInput string

const (
	ChunkOrderByInputIDAsc          ChunkOrderByInput = "id_ASC"
	ChunkOrderByInputIDDesc         ChunkOrderByInput = "id_DESC"
	ChunkOrderByInputCreatedAtAsc   ChunkOrderByInput = "createdAt_ASC"
	ChunkOrderByInputCreatedAtDesc  ChunkOrderByInput = "createdAt_DESC"
	ChunkOrderByInputUpdatedAtAsc   ChunkOrderByInput = "updatedAt_ASC"
	ChunkOrderByInputUpdatedAtDesc  ChunkOrderByInput = "updatedAt_DESC"
	ChunkOrderByInputRangeStartAsc  ChunkOrderByInput = "rangeStart_ASC"
	ChunkOrderByInputRangeStartDesc ChunkOrderByInput = "rangeStart_DESC"
	ChunkOrderByInputRangeEndAsc    ChunkOrderByInput = "rangeEnd_ASC"
	ChunkOrderByInputRangeEndDesc   ChunkOrderByInput = "rangeEnd_DESC"
)

type OrganizationOrderByInput string

const (
	OrganizationOrderByInputIDAsc         OrganizationOrderByInput = "id_ASC"
	OrganizationOrderByInputIDDesc        OrganizationOrderByInput = "id_DESC"
	OrganizationOrderByInputCreatedAtAsc  OrganizationOrderByInput = "createdAt_ASC"
	OrganizationOrderByInputCreatedAtDesc OrganizationOrderByInput = "createdAt_DESC"
	OrganizationOrderByInputUpdatedAtAsc  OrganizationOrderByInput = "updatedAt_ASC"
	OrganizationOrderByInputUpdatedAtDesc OrganizationOrderByInput = "updatedAt_DESC"
	OrganizationOrderByInputNameAsc       OrganizationOrderByInput = "name_ASC"
	OrganizationOrderByInputNameDesc      OrganizationOrderByInput = "name_DESC"
)

type UploadOrderByInput string

const (
	UploadOrderByInputIDAsc         UploadOrderByInput = "id_ASC"
	UploadOrderByInputIDDesc        UploadOrderByInput = "id_DESC"
	UploadOrderByInputCreatedAtAsc  UploadOrderByInput = "createdAt_ASC"
	UploadOrderByInputCreatedAtDesc UploadOrderByInput = "createdAt_DESC"
	UploadOrderByInputUpdatedAtAsc  UploadOrderByInput = "updatedAt_ASC"
	UploadOrderByInputUpdatedAtDesc UploadOrderByInput = "updatedAt_DESC"
	UploadOrderByInputUuidAsc       UploadOrderByInput = "uuid_ASC"
	UploadOrderByInputUuidDesc      UploadOrderByInput = "uuid_DESC"
	UploadOrderByInputDoneAsc       UploadOrderByInput = "done_ASC"
	UploadOrderByInputDoneDesc      UploadOrderByInput = "done_DESC"
)

type MutationType string

const (
	MutationTypeCreated MutationType = "CREATED"
	MutationTypeUpdated MutationType = "UPDATED"
	MutationTypeDeleted MutationType = "DELETED"
)

type BlobWhereUniqueInput struct {
	ID     *string `json:"id,omitempty"`
	Digest *string `json:"digest,omitempty"`
}

type RepositoryWhereInput struct {
	ID                *string                 `json:"id,omitempty"`
	IDNot             *string                 `json:"id_not,omitempty"`
	IDIn              []string                `json:"id_in,omitempty"`
	IDNotIn           []string                `json:"id_not_in,omitempty"`
	IDLt              *string                 `json:"id_lt,omitempty"`
	IDLte             *string                 `json:"id_lte,omitempty"`
	IDGt              *string                 `json:"id_gt,omitempty"`
	IDGte             *string                 `json:"id_gte,omitempty"`
	IDContains        *string                 `json:"id_contains,omitempty"`
	IDNotContains     *string                 `json:"id_not_contains,omitempty"`
	IDStartsWith      *string                 `json:"id_starts_with,omitempty"`
	IDNotStartsWith   *string                 `json:"id_not_starts_with,omitempty"`
	IDEndsWith        *string                 `json:"id_ends_with,omitempty"`
	IDNotEndsWith     *string                 `json:"id_not_ends_with,omitempty"`
	CreatedAt         *string                 `json:"createdAt,omitempty"`
	CreatedAtNot      *string                 `json:"createdAt_not,omitempty"`
	CreatedAtIn       []string                `json:"createdAt_in,omitempty"`
	CreatedAtNotIn    []string                `json:"createdAt_not_in,omitempty"`
	CreatedAtLt       *string                 `json:"createdAt_lt,omitempty"`
	CreatedAtLte      *string                 `json:"createdAt_lte,omitempty"`
	CreatedAtGt       *string                 `json:"createdAt_gt,omitempty"`
	CreatedAtGte      *string                 `json:"createdAt_gte,omitempty"`
	UpdatedAt         *string                 `json:"updatedAt,omitempty"`
	UpdatedAtNot      *string                 `json:"updatedAt_not,omitempty"`
	UpdatedAtIn       []string                `json:"updatedAt_in,omitempty"`
	UpdatedAtNotIn    []string                `json:"updatedAt_not_in,omitempty"`
	UpdatedAtLt       *string                 `json:"updatedAt_lt,omitempty"`
	UpdatedAtLte      *string                 `json:"updatedAt_lte,omitempty"`
	UpdatedAtGt       *string                 `json:"updatedAt_gt,omitempty"`
	UpdatedAtGte      *string                 `json:"updatedAt_gte,omitempty"`
	Name              *string                 `json:"name,omitempty"`
	NameNot           *string                 `json:"name_not,omitempty"`
	NameIn            []string                `json:"name_in,omitempty"`
	NameNotIn         []string                `json:"name_not_in,omitempty"`
	NameLt            *string                 `json:"name_lt,omitempty"`
	NameLte           *string                 `json:"name_lte,omitempty"`
	NameGt            *string                 `json:"name_gt,omitempty"`
	NameGte           *string                 `json:"name_gte,omitempty"`
	NameContains      *string                 `json:"name_contains,omitempty"`
	NameNotContains   *string                 `json:"name_not_contains,omitempty"`
	NameStartsWith    *string                 `json:"name_starts_with,omitempty"`
	NameNotStartsWith *string                 `json:"name_not_starts_with,omitempty"`
	NameEndsWith      *string                 `json:"name_ends_with,omitempty"`
	NameNotEndsWith   *string                 `json:"name_not_ends_with,omitempty"`
	Org               *OrganizationWhereInput `json:"org,omitempty"`
	BlobsEvery        *BlobWhereInput         `json:"blobs_every,omitempty"`
	BlobsSome         *BlobWhereInput         `json:"blobs_some,omitempty"`
	BlobsNone         *BlobWhereInput         `json:"blobs_none,omitempty"`
	And               []RepositoryWhereInput  `json:"AND,omitempty"`
	Or                []RepositoryWhereInput  `json:"OR,omitempty"`
	Not               []RepositoryWhereInput  `json:"NOT,omitempty"`
}

type OrganizationWhereInput struct {
	ID                *string                  `json:"id,omitempty"`
	IDNot             *string                  `json:"id_not,omitempty"`
	IDIn              []string                 `json:"id_in,omitempty"`
	IDNotIn           []string                 `json:"id_not_in,omitempty"`
	IDLt              *string                  `json:"id_lt,omitempty"`
	IDLte             *string                  `json:"id_lte,omitempty"`
	IDGt              *string                  `json:"id_gt,omitempty"`
	IDGte             *string                  `json:"id_gte,omitempty"`
	IDContains        *string                  `json:"id_contains,omitempty"`
	IDNotContains     *string                  `json:"id_not_contains,omitempty"`
	IDStartsWith      *string                  `json:"id_starts_with,omitempty"`
	IDNotStartsWith   *string                  `json:"id_not_starts_with,omitempty"`
	IDEndsWith        *string                  `json:"id_ends_with,omitempty"`
	IDNotEndsWith     *string                  `json:"id_not_ends_with,omitempty"`
	CreatedAt         *string                  `json:"createdAt,omitempty"`
	CreatedAtNot      *string                  `json:"createdAt_not,omitempty"`
	CreatedAtIn       []string                 `json:"createdAt_in,omitempty"`
	CreatedAtNotIn    []string                 `json:"createdAt_not_in,omitempty"`
	CreatedAtLt       *string                  `json:"createdAt_lt,omitempty"`
	CreatedAtLte      *string                  `json:"createdAt_lte,omitempty"`
	CreatedAtGt       *string                  `json:"createdAt_gt,omitempty"`
	CreatedAtGte      *string                  `json:"createdAt_gte,omitempty"`
	UpdatedAt         *string                  `json:"updatedAt,omitempty"`
	UpdatedAtNot      *string                  `json:"updatedAt_not,omitempty"`
	UpdatedAtIn       []string                 `json:"updatedAt_in,omitempty"`
	UpdatedAtNotIn    []string                 `json:"updatedAt_not_in,omitempty"`
	UpdatedAtLt       *string                  `json:"updatedAt_lt,omitempty"`
	UpdatedAtLte      *string                  `json:"updatedAt_lte,omitempty"`
	UpdatedAtGt       *string                  `json:"updatedAt_gt,omitempty"`
	UpdatedAtGte      *string                  `json:"updatedAt_gte,omitempty"`
	Name              *string                  `json:"name,omitempty"`
	NameNot           *string                  `json:"name_not,omitempty"`
	NameIn            []string                 `json:"name_in,omitempty"`
	NameNotIn         []string                 `json:"name_not_in,omitempty"`
	NameLt            *string                  `json:"name_lt,omitempty"`
	NameLte           *string                  `json:"name_lte,omitempty"`
	NameGt            *string                  `json:"name_gt,omitempty"`
	NameGte           *string                  `json:"name_gte,omitempty"`
	NameContains      *string                  `json:"name_contains,omitempty"`
	NameNotContains   *string                  `json:"name_not_contains,omitempty"`
	NameStartsWith    *string                  `json:"name_starts_with,omitempty"`
	NameNotStartsWith *string                  `json:"name_not_starts_with,omitempty"`
	NameEndsWith      *string                  `json:"name_ends_with,omitempty"`
	NameNotEndsWith   *string                  `json:"name_not_ends_with,omitempty"`
	ReposEvery        *RepositoryWhereInput    `json:"repos_every,omitempty"`
	ReposSome         *RepositoryWhereInput    `json:"repos_some,omitempty"`
	ReposNone         *RepositoryWhereInput    `json:"repos_none,omitempty"`
	BlobsEvery        *BlobWhereInput          `json:"blobs_every,omitempty"`
	BlobsSome         *BlobWhereInput          `json:"blobs_some,omitempty"`
	BlobsNone         *BlobWhereInput          `json:"blobs_none,omitempty"`
	ImagesEvery       *ImageWhereInput         `json:"images_every,omitempty"`
	ImagesSome        *ImageWhereInput         `json:"images_some,omitempty"`
	ImagesNone        *ImageWhereInput         `json:"images_none,omitempty"`
	And               []OrganizationWhereInput `json:"AND,omitempty"`
	Or                []OrganizationWhereInput `json:"OR,omitempty"`
	Not               []OrganizationWhereInput `json:"NOT,omitempty"`
}

type BlobWhereInput struct {
	ID                  *string               `json:"id,omitempty"`
	IDNot               *string               `json:"id_not,omitempty"`
	IDIn                []string              `json:"id_in,omitempty"`
	IDNotIn             []string              `json:"id_not_in,omitempty"`
	IDLt                *string               `json:"id_lt,omitempty"`
	IDLte               *string               `json:"id_lte,omitempty"`
	IDGt                *string               `json:"id_gt,omitempty"`
	IDGte               *string               `json:"id_gte,omitempty"`
	IDContains          *string               `json:"id_contains,omitempty"`
	IDNotContains       *string               `json:"id_not_contains,omitempty"`
	IDStartsWith        *string               `json:"id_starts_with,omitempty"`
	IDNotStartsWith     *string               `json:"id_not_starts_with,omitempty"`
	IDEndsWith          *string               `json:"id_ends_with,omitempty"`
	IDNotEndsWith       *string               `json:"id_not_ends_with,omitempty"`
	CreatedAt           *string               `json:"createdAt,omitempty"`
	CreatedAtNot        *string               `json:"createdAt_not,omitempty"`
	CreatedAtIn         []string              `json:"createdAt_in,omitempty"`
	CreatedAtNotIn      []string              `json:"createdAt_not_in,omitempty"`
	CreatedAtLt         *string               `json:"createdAt_lt,omitempty"`
	CreatedAtLte        *string               `json:"createdAt_lte,omitempty"`
	CreatedAtGt         *string               `json:"createdAt_gt,omitempty"`
	CreatedAtGte        *string               `json:"createdAt_gte,omitempty"`
	UpdatedAt           *string               `json:"updatedAt,omitempty"`
	UpdatedAtNot        *string               `json:"updatedAt_not,omitempty"`
	UpdatedAtIn         []string              `json:"updatedAt_in,omitempty"`
	UpdatedAtNotIn      []string              `json:"updatedAt_not_in,omitempty"`
	UpdatedAtLt         *string               `json:"updatedAt_lt,omitempty"`
	UpdatedAtLte        *string               `json:"updatedAt_lte,omitempty"`
	UpdatedAtGt         *string               `json:"updatedAt_gt,omitempty"`
	UpdatedAtGte        *string               `json:"updatedAt_gte,omitempty"`
	Digest              *string               `json:"digest,omitempty"`
	DigestNot           *string               `json:"digest_not,omitempty"`
	DigestIn            []string              `json:"digest_in,omitempty"`
	DigestNotIn         []string              `json:"digest_not_in,omitempty"`
	DigestLt            *string               `json:"digest_lt,omitempty"`
	DigestLte           *string               `json:"digest_lte,omitempty"`
	DigestGt            *string               `json:"digest_gt,omitempty"`
	DigestGte           *string               `json:"digest_gte,omitempty"`
	DigestContains      *string               `json:"digest_contains,omitempty"`
	DigestNotContains   *string               `json:"digest_not_contains,omitempty"`
	DigestStartsWith    *string               `json:"digest_starts_with,omitempty"`
	DigestNotStartsWith *string               `json:"digest_not_starts_with,omitempty"`
	DigestEndsWith      *string               `json:"digest_ends_with,omitempty"`
	DigestNotEndsWith   *string               `json:"digest_not_ends_with,omitempty"`
	Repo                *RepositoryWhereInput `json:"repo,omitempty"`
	And                 []BlobWhereInput      `json:"AND,omitempty"`
	Or                  []BlobWhereInput      `json:"OR,omitempty"`
	Not                 []BlobWhereInput      `json:"NOT,omitempty"`
}

type ImageWhereInput struct {
	ID                        *string               `json:"id,omitempty"`
	IDNot                     *string               `json:"id_not,omitempty"`
	IDIn                      []string              `json:"id_in,omitempty"`
	IDNotIn                   []string              `json:"id_not_in,omitempty"`
	IDLt                      *string               `json:"id_lt,omitempty"`
	IDLte                     *string               `json:"id_lte,omitempty"`
	IDGt                      *string               `json:"id_gt,omitempty"`
	IDGte                     *string               `json:"id_gte,omitempty"`
	IDContains                *string               `json:"id_contains,omitempty"`
	IDNotContains             *string               `json:"id_not_contains,omitempty"`
	IDStartsWith              *string               `json:"id_starts_with,omitempty"`
	IDNotStartsWith           *string               `json:"id_not_starts_with,omitempty"`
	IDEndsWith                *string               `json:"id_ends_with,omitempty"`
	IDNotEndsWith             *string               `json:"id_not_ends_with,omitempty"`
	CreatedAt                 *string               `json:"createdAt,omitempty"`
	CreatedAtNot              *string               `json:"createdAt_not,omitempty"`
	CreatedAtIn               []string              `json:"createdAt_in,omitempty"`
	CreatedAtNotIn            []string              `json:"createdAt_not_in,omitempty"`
	CreatedAtLt               *string               `json:"createdAt_lt,omitempty"`
	CreatedAtLte              *string               `json:"createdAt_lte,omitempty"`
	CreatedAtGt               *string               `json:"createdAt_gt,omitempty"`
	CreatedAtGte              *string               `json:"createdAt_gte,omitempty"`
	UpdatedAt                 *string               `json:"updatedAt,omitempty"`
	UpdatedAtNot              *string               `json:"updatedAt_not,omitempty"`
	UpdatedAtIn               []string              `json:"updatedAt_in,omitempty"`
	UpdatedAtNotIn            []string              `json:"updatedAt_not_in,omitempty"`
	UpdatedAtLt               *string               `json:"updatedAt_lt,omitempty"`
	UpdatedAtLte              *string               `json:"updatedAt_lte,omitempty"`
	UpdatedAtGt               *string               `json:"updatedAt_gt,omitempty"`
	UpdatedAtGte              *string               `json:"updatedAt_gte,omitempty"`
	Repo                      *RepositoryWhereInput `json:"repo,omitempty"`
	Digest                    *string               `json:"digest,omitempty"`
	DigestNot                 *string               `json:"digest_not,omitempty"`
	DigestIn                  []string              `json:"digest_in,omitempty"`
	DigestNotIn               []string              `json:"digest_not_in,omitempty"`
	DigestLt                  *string               `json:"digest_lt,omitempty"`
	DigestLte                 *string               `json:"digest_lte,omitempty"`
	DigestGt                  *string               `json:"digest_gt,omitempty"`
	DigestGte                 *string               `json:"digest_gte,omitempty"`
	DigestContains            *string               `json:"digest_contains,omitempty"`
	DigestNotContains         *string               `json:"digest_not_contains,omitempty"`
	DigestStartsWith          *string               `json:"digest_starts_with,omitempty"`
	DigestNotStartsWith       *string               `json:"digest_not_starts_with,omitempty"`
	DigestEndsWith            *string               `json:"digest_ends_with,omitempty"`
	DigestNotEndsWith         *string               `json:"digest_not_ends_with,omitempty"`
	ManifestType              *string               `json:"manifest_type,omitempty"`
	ManifestTypeNot           *string               `json:"manifest_type_not,omitempty"`
	ManifestTypeIn            []string              `json:"manifest_type_in,omitempty"`
	ManifestTypeNotIn         []string              `json:"manifest_type_not_in,omitempty"`
	ManifestTypeLt            *string               `json:"manifest_type_lt,omitempty"`
	ManifestTypeLte           *string               `json:"manifest_type_lte,omitempty"`
	ManifestTypeGt            *string               `json:"manifest_type_gt,omitempty"`
	ManifestTypeGte           *string               `json:"manifest_type_gte,omitempty"`
	ManifestTypeContains      *string               `json:"manifest_type_contains,omitempty"`
	ManifestTypeNotContains   *string               `json:"manifest_type_not_contains,omitempty"`
	ManifestTypeStartsWith    *string               `json:"manifest_type_starts_with,omitempty"`
	ManifestTypeNotStartsWith *string               `json:"manifest_type_not_starts_with,omitempty"`
	ManifestTypeEndsWith      *string               `json:"manifest_type_ends_with,omitempty"`
	ManifestTypeNotEndsWith   *string               `json:"manifest_type_not_ends_with,omitempty"`
	TagsEvery                 *TagWhereInput        `json:"tags_every,omitempty"`
	TagsSome                  *TagWhereInput        `json:"tags_some,omitempty"`
	TagsNone                  *TagWhereInput        `json:"tags_none,omitempty"`
	And                       []ImageWhereInput     `json:"AND,omitempty"`
	Or                        []ImageWhereInput     `json:"OR,omitempty"`
	Not                       []ImageWhereInput     `json:"NOT,omitempty"`
}

type TagWhereInput struct {
	ID              *string          `json:"id,omitempty"`
	IDNot           *string          `json:"id_not,omitempty"`
	IDIn            []string         `json:"id_in,omitempty"`
	IDNotIn         []string         `json:"id_not_in,omitempty"`
	IDLt            *string          `json:"id_lt,omitempty"`
	IDLte           *string          `json:"id_lte,omitempty"`
	IDGt            *string          `json:"id_gt,omitempty"`
	IDGte           *string          `json:"id_gte,omitempty"`
	IDContains      *string          `json:"id_contains,omitempty"`
	IDNotContains   *string          `json:"id_not_contains,omitempty"`
	IDStartsWith    *string          `json:"id_starts_with,omitempty"`
	IDNotStartsWith *string          `json:"id_not_starts_with,omitempty"`
	IDEndsWith      *string          `json:"id_ends_with,omitempty"`
	IDNotEndsWith   *string          `json:"id_not_ends_with,omitempty"`
	CreatedAt       *string          `json:"createdAt,omitempty"`
	CreatedAtNot    *string          `json:"createdAt_not,omitempty"`
	CreatedAtIn     []string         `json:"createdAt_in,omitempty"`
	CreatedAtNotIn  []string         `json:"createdAt_not_in,omitempty"`
	CreatedAtLt     *string          `json:"createdAt_lt,omitempty"`
	CreatedAtLte    *string          `json:"createdAt_lte,omitempty"`
	CreatedAtGt     *string          `json:"createdAt_gt,omitempty"`
	CreatedAtGte    *string          `json:"createdAt_gte,omitempty"`
	UpdatedAt       *string          `json:"updatedAt,omitempty"`
	UpdatedAtNot    *string          `json:"updatedAt_not,omitempty"`
	UpdatedAtIn     []string         `json:"updatedAt_in,omitempty"`
	UpdatedAtNotIn  []string         `json:"updatedAt_not_in,omitempty"`
	UpdatedAtLt     *string          `json:"updatedAt_lt,omitempty"`
	UpdatedAtLte    *string          `json:"updatedAt_lte,omitempty"`
	UpdatedAtGt     *string          `json:"updatedAt_gt,omitempty"`
	UpdatedAtGte    *string          `json:"updatedAt_gte,omitempty"`
	Image           *ImageWhereInput `json:"image,omitempty"`
	And             []TagWhereInput  `json:"AND,omitempty"`
	Or              []TagWhereInput  `json:"OR,omitempty"`
	Not             []TagWhereInput  `json:"NOT,omitempty"`
}

type ChunkWhereUniqueInput struct {
	ID *string `json:"id,omitempty"`
}

type ChunkWhereInput struct {
	ID              *string           `json:"id,omitempty"`
	IDNot           *string           `json:"id_not,omitempty"`
	IDIn            []string          `json:"id_in,omitempty"`
	IDNotIn         []string          `json:"id_not_in,omitempty"`
	IDLt            *string           `json:"id_lt,omitempty"`
	IDLte           *string           `json:"id_lte,omitempty"`
	IDGt            *string           `json:"id_gt,omitempty"`
	IDGte           *string           `json:"id_gte,omitempty"`
	IDContains      *string           `json:"id_contains,omitempty"`
	IDNotContains   *string           `json:"id_not_contains,omitempty"`
	IDStartsWith    *string           `json:"id_starts_with,omitempty"`
	IDNotStartsWith *string           `json:"id_not_starts_with,omitempty"`
	IDEndsWith      *string           `json:"id_ends_with,omitempty"`
	IDNotEndsWith   *string           `json:"id_not_ends_with,omitempty"`
	CreatedAt       *string           `json:"createdAt,omitempty"`
	CreatedAtNot    *string           `json:"createdAt_not,omitempty"`
	CreatedAtIn     []string          `json:"createdAt_in,omitempty"`
	CreatedAtNotIn  []string          `json:"createdAt_not_in,omitempty"`
	CreatedAtLt     *string           `json:"createdAt_lt,omitempty"`
	CreatedAtLte    *string           `json:"createdAt_lte,omitempty"`
	CreatedAtGt     *string           `json:"createdAt_gt,omitempty"`
	CreatedAtGte    *string           `json:"createdAt_gte,omitempty"`
	UpdatedAt       *string           `json:"updatedAt,omitempty"`
	UpdatedAtNot    *string           `json:"updatedAt_not,omitempty"`
	UpdatedAtIn     []string          `json:"updatedAt_in,omitempty"`
	UpdatedAtNotIn  []string          `json:"updatedAt_not_in,omitempty"`
	UpdatedAtLt     *string           `json:"updatedAt_lt,omitempty"`
	UpdatedAtLte    *string           `json:"updatedAt_lte,omitempty"`
	UpdatedAtGt     *string           `json:"updatedAt_gt,omitempty"`
	UpdatedAtGte    *string           `json:"updatedAt_gte,omitempty"`
	Upload          *UploadWhereInput `json:"upload,omitempty"`
	RangeStart      *int32            `json:"rangeStart,omitempty"`
	RangeStartNot   *int32            `json:"rangeStart_not,omitempty"`
	RangeStartIn    []int32           `json:"rangeStart_in,omitempty"`
	RangeStartNotIn []int32           `json:"rangeStart_not_in,omitempty"`
	RangeStartLt    *int32            `json:"rangeStart_lt,omitempty"`
	RangeStartLte   *int32            `json:"rangeStart_lte,omitempty"`
	RangeStartGt    *int32            `json:"rangeStart_gt,omitempty"`
	RangeStartGte   *int32            `json:"rangeStart_gte,omitempty"`
	RangeEnd        *int32            `json:"rangeEnd,omitempty"`
	RangeEndNot     *int32            `json:"rangeEnd_not,omitempty"`
	RangeEndIn      []int32           `json:"rangeEnd_in,omitempty"`
	RangeEndNotIn   []int32           `json:"rangeEnd_not_in,omitempty"`
	RangeEndLt      *int32            `json:"rangeEnd_lt,omitempty"`
	RangeEndLte     *int32            `json:"rangeEnd_lte,omitempty"`
	RangeEndGt      *int32            `json:"rangeEnd_gt,omitempty"`
	RangeEndGte     *int32            `json:"rangeEnd_gte,omitempty"`
	And             []ChunkWhereInput `json:"AND,omitempty"`
	Or              []ChunkWhereInput `json:"OR,omitempty"`
	Not             []ChunkWhereInput `json:"NOT,omitempty"`
}

type UploadWhereInput struct {
	ID                *string            `json:"id,omitempty"`
	IDNot             *string            `json:"id_not,omitempty"`
	IDIn              []string           `json:"id_in,omitempty"`
	IDNotIn           []string           `json:"id_not_in,omitempty"`
	IDLt              *string            `json:"id_lt,omitempty"`
	IDLte             *string            `json:"id_lte,omitempty"`
	IDGt              *string            `json:"id_gt,omitempty"`
	IDGte             *string            `json:"id_gte,omitempty"`
	IDContains        *string            `json:"id_contains,omitempty"`
	IDNotContains     *string            `json:"id_not_contains,omitempty"`
	IDStartsWith      *string            `json:"id_starts_with,omitempty"`
	IDNotStartsWith   *string            `json:"id_not_starts_with,omitempty"`
	IDEndsWith        *string            `json:"id_ends_with,omitempty"`
	IDNotEndsWith     *string            `json:"id_not_ends_with,omitempty"`
	CreatedAt         *string            `json:"createdAt,omitempty"`
	CreatedAtNot      *string            `json:"createdAt_not,omitempty"`
	CreatedAtIn       []string           `json:"createdAt_in,omitempty"`
	CreatedAtNotIn    []string           `json:"createdAt_not_in,omitempty"`
	CreatedAtLt       *string            `json:"createdAt_lt,omitempty"`
	CreatedAtLte      *string            `json:"createdAt_lte,omitempty"`
	CreatedAtGt       *string            `json:"createdAt_gt,omitempty"`
	CreatedAtGte      *string            `json:"createdAt_gte,omitempty"`
	UpdatedAt         *string            `json:"updatedAt,omitempty"`
	UpdatedAtNot      *string            `json:"updatedAt_not,omitempty"`
	UpdatedAtIn       []string           `json:"updatedAt_in,omitempty"`
	UpdatedAtNotIn    []string           `json:"updatedAt_not_in,omitempty"`
	UpdatedAtLt       *string            `json:"updatedAt_lt,omitempty"`
	UpdatedAtLte      *string            `json:"updatedAt_lte,omitempty"`
	UpdatedAtGt       *string            `json:"updatedAt_gt,omitempty"`
	UpdatedAtGte      *string            `json:"updatedAt_gte,omitempty"`
	Uuid              *string            `json:"uuid,omitempty"`
	UuidNot           *string            `json:"uuid_not,omitempty"`
	UuidIn            []string           `json:"uuid_in,omitempty"`
	UuidNotIn         []string           `json:"uuid_not_in,omitempty"`
	UuidLt            *string            `json:"uuid_lt,omitempty"`
	UuidLte           *string            `json:"uuid_lte,omitempty"`
	UuidGt            *string            `json:"uuid_gt,omitempty"`
	UuidGte           *string            `json:"uuid_gte,omitempty"`
	UuidContains      *string            `json:"uuid_contains,omitempty"`
	UuidNotContains   *string            `json:"uuid_not_contains,omitempty"`
	UuidStartsWith    *string            `json:"uuid_starts_with,omitempty"`
	UuidNotStartsWith *string            `json:"uuid_not_starts_with,omitempty"`
	UuidEndsWith      *string            `json:"uuid_ends_with,omitempty"`
	UuidNotEndsWith   *string            `json:"uuid_not_ends_with,omitempty"`
	Done              *bool              `json:"done,omitempty"`
	DoneNot           *bool              `json:"done_not,omitempty"`
	ChunksEvery       *ChunkWhereInput   `json:"chunks_every,omitempty"`
	ChunksSome        *ChunkWhereInput   `json:"chunks_some,omitempty"`
	ChunksNone        *ChunkWhereInput   `json:"chunks_none,omitempty"`
	And               []UploadWhereInput `json:"AND,omitempty"`
	Or                []UploadWhereInput `json:"OR,omitempty"`
	Not               []UploadWhereInput `json:"NOT,omitempty"`
}

type ImageWhereUniqueInput struct {
	ID     *string `json:"id,omitempty"`
	Digest *string `json:"digest,omitempty"`
}

type OrganizationWhereUniqueInput struct {
	ID   *string `json:"id,omitempty"`
	Name *string `json:"name,omitempty"`
}

type RepositoryWhereUniqueInput struct {
	ID *string `json:"id,omitempty"`
}

type TagWhereUniqueInput struct {
	ID *string `json:"id,omitempty"`
}

type UploadWhereUniqueInput struct {
	ID   *string `json:"id,omitempty"`
	Uuid *string `json:"uuid,omitempty"`
}

type BlobCreateInput struct {
	ID     *string                              `json:"id,omitempty"`
	Digest string                               `json:"digest"`
	Repo   RepositoryCreateOneWithoutBlobsInput `json:"repo"`
}

type RepositoryCreateOneWithoutBlobsInput struct {
	Create  *RepositoryCreateWithoutBlobsInput `json:"create,omitempty"`
	Connect *RepositoryWhereUniqueInput        `json:"connect,omitempty"`
}

type RepositoryCreateWithoutBlobsInput struct {
	ID   *string                                `json:"id,omitempty"`
	Name string                                 `json:"name"`
	Org  OrganizationCreateOneWithoutReposInput `json:"org"`
}

type OrganizationCreateOneWithoutReposInput struct {
	Create  *OrganizationCreateWithoutReposInput `json:"create,omitempty"`
	Connect *OrganizationWhereUniqueInput        `json:"connect,omitempty"`
}

type OrganizationCreateWithoutReposInput struct {
	ID     *string               `json:"id,omitempty"`
	Name   string                `json:"name"`
	Blobs  *BlobCreateManyInput  `json:"blobs,omitempty"`
	Images *ImageCreateManyInput `json:"images,omitempty"`
}

type BlobCreateManyInput struct {
	Create  []BlobCreateInput      `json:"create,omitempty"`
	Connect []BlobWhereUniqueInput `json:"connect,omitempty"`
}

type ImageCreateManyInput struct {
	Create  []ImageCreateInput      `json:"create,omitempty"`
	Connect []ImageWhereUniqueInput `json:"connect,omitempty"`
}

type ImageCreateInput struct {
	ID           *string                         `json:"id,omitempty"`
	Repo         RepositoryCreateOneInput        `json:"repo"`
	Digest       string                          `json:"digest"`
	Manifest     map[string]interface{}          `json:"manifest"`
	ManifestType string                          `json:"manifest_type"`
	Tags         *TagCreateManyWithoutImageInput `json:"tags,omitempty"`
}

type RepositoryCreateOneInput struct {
	Create  *RepositoryCreateInput      `json:"create,omitempty"`
	Connect *RepositoryWhereUniqueInput `json:"connect,omitempty"`
}

type RepositoryCreateInput struct {
	ID    *string                                `json:"id,omitempty"`
	Name  string                                 `json:"name"`
	Org   OrganizationCreateOneWithoutReposInput `json:"org"`
	Blobs *BlobCreateManyWithoutRepoInput        `json:"blobs,omitempty"`
}

type BlobCreateManyWithoutRepoInput struct {
	Create  []BlobCreateWithoutRepoInput `json:"create,omitempty"`
	Connect []BlobWhereUniqueInput       `json:"connect,omitempty"`
}

type BlobCreateWithoutRepoInput struct {
	ID     *string `json:"id,omitempty"`
	Digest string  `json:"digest"`
}

type TagCreateManyWithoutImageInput struct {
	Create  []TagCreateWithoutImageInput `json:"create,omitempty"`
	Connect []TagWhereUniqueInput        `json:"connect,omitempty"`
}

type TagCreateWithoutImageInput struct {
	ID *string `json:"id,omitempty"`
}

type BlobUpdateInput struct {
	Digest *string                                       `json:"digest,omitempty"`
	Repo   *RepositoryUpdateOneRequiredWithoutBlobsInput `json:"repo,omitempty"`
}

type RepositoryUpdateOneRequiredWithoutBlobsInput struct {
	Create  *RepositoryCreateWithoutBlobsInput     `json:"create,omitempty"`
	Update  *RepositoryUpdateWithoutBlobsDataInput `json:"update,omitempty"`
	Upsert  *RepositoryUpsertWithoutBlobsInput     `json:"upsert,omitempty"`
	Connect *RepositoryWhereUniqueInput            `json:"connect,omitempty"`
}

type RepositoryUpdateWithoutBlobsDataInput struct {
	Name *string                                         `json:"name,omitempty"`
	Org  *OrganizationUpdateOneRequiredWithoutReposInput `json:"org,omitempty"`
}

type OrganizationUpdateOneRequiredWithoutReposInput struct {
	Create  *OrganizationCreateWithoutReposInput     `json:"create,omitempty"`
	Update  *OrganizationUpdateWithoutReposDataInput `json:"update,omitempty"`
	Upsert  *OrganizationUpsertWithoutReposInput     `json:"upsert,omitempty"`
	Connect *OrganizationWhereUniqueInput            `json:"connect,omitempty"`
}

type OrganizationUpdateWithoutReposDataInput struct {
	Name   *string               `json:"name,omitempty"`
	Blobs  *BlobUpdateManyInput  `json:"blobs,omitempty"`
	Images *ImageUpdateManyInput `json:"images,omitempty"`
}

type BlobUpdateManyInput struct {
	Create     []BlobCreateInput                      `json:"create,omitempty"`
	Update     []BlobUpdateWithWhereUniqueNestedInput `json:"update,omitempty"`
	Upsert     []BlobUpsertWithWhereUniqueNestedInput `json:"upsert,omitempty"`
	Delete     []BlobWhereUniqueInput                 `json:"delete,omitempty"`
	Connect    []BlobWhereUniqueInput                 `json:"connect,omitempty"`
	Set        []BlobWhereUniqueInput                 `json:"set,omitempty"`
	Disconnect []BlobWhereUniqueInput                 `json:"disconnect,omitempty"`
	DeleteMany []BlobScalarWhereInput                 `json:"deleteMany,omitempty"`
	UpdateMany []BlobUpdateManyWithWhereNestedInput   `json:"updateMany,omitempty"`
}

type BlobUpdateWithWhereUniqueNestedInput struct {
	Where BlobWhereUniqueInput `json:"where"`
	Data  BlobUpdateDataInput  `json:"data"`
}

type BlobUpdateDataInput struct {
	Digest *string                                       `json:"digest,omitempty"`
	Repo   *RepositoryUpdateOneRequiredWithoutBlobsInput `json:"repo,omitempty"`
}

type BlobUpsertWithWhereUniqueNestedInput struct {
	Where  BlobWhereUniqueInput `json:"where"`
	Update BlobUpdateDataInput  `json:"update"`
	Create BlobCreateInput      `json:"create"`
}

type BlobScalarWhereInput struct {
	ID                  *string                `json:"id,omitempty"`
	IDNot               *string                `json:"id_not,omitempty"`
	IDIn                []string               `json:"id_in,omitempty"`
	IDNotIn             []string               `json:"id_not_in,omitempty"`
	IDLt                *string                `json:"id_lt,omitempty"`
	IDLte               *string                `json:"id_lte,omitempty"`
	IDGt                *string                `json:"id_gt,omitempty"`
	IDGte               *string                `json:"id_gte,omitempty"`
	IDContains          *string                `json:"id_contains,omitempty"`
	IDNotContains       *string                `json:"id_not_contains,omitempty"`
	IDStartsWith        *string                `json:"id_starts_with,omitempty"`
	IDNotStartsWith     *string                `json:"id_not_starts_with,omitempty"`
	IDEndsWith          *string                `json:"id_ends_with,omitempty"`
	IDNotEndsWith       *string                `json:"id_not_ends_with,omitempty"`
	CreatedAt           *string                `json:"createdAt,omitempty"`
	CreatedAtNot        *string                `json:"createdAt_not,omitempty"`
	CreatedAtIn         []string               `json:"createdAt_in,omitempty"`
	CreatedAtNotIn      []string               `json:"createdAt_not_in,omitempty"`
	CreatedAtLt         *string                `json:"createdAt_lt,omitempty"`
	CreatedAtLte        *string                `json:"createdAt_lte,omitempty"`
	CreatedAtGt         *string                `json:"createdAt_gt,omitempty"`
	CreatedAtGte        *string                `json:"createdAt_gte,omitempty"`
	UpdatedAt           *string                `json:"updatedAt,omitempty"`
	UpdatedAtNot        *string                `json:"updatedAt_not,omitempty"`
	UpdatedAtIn         []string               `json:"updatedAt_in,omitempty"`
	UpdatedAtNotIn      []string               `json:"updatedAt_not_in,omitempty"`
	UpdatedAtLt         *string                `json:"updatedAt_lt,omitempty"`
	UpdatedAtLte        *string                `json:"updatedAt_lte,omitempty"`
	UpdatedAtGt         *string                `json:"updatedAt_gt,omitempty"`
	UpdatedAtGte        *string                `json:"updatedAt_gte,omitempty"`
	Digest              *string                `json:"digest,omitempty"`
	DigestNot           *string                `json:"digest_not,omitempty"`
	DigestIn            []string               `json:"digest_in,omitempty"`
	DigestNotIn         []string               `json:"digest_not_in,omitempty"`
	DigestLt            *string                `json:"digest_lt,omitempty"`
	DigestLte           *string                `json:"digest_lte,omitempty"`
	DigestGt            *string                `json:"digest_gt,omitempty"`
	DigestGte           *string                `json:"digest_gte,omitempty"`
	DigestContains      *string                `json:"digest_contains,omitempty"`
	DigestNotContains   *string                `json:"digest_not_contains,omitempty"`
	DigestStartsWith    *string                `json:"digest_starts_with,omitempty"`
	DigestNotStartsWith *string                `json:"digest_not_starts_with,omitempty"`
	DigestEndsWith      *string                `json:"digest_ends_with,omitempty"`
	DigestNotEndsWith   *string                `json:"digest_not_ends_with,omitempty"`
	And                 []BlobScalarWhereInput `json:"AND,omitempty"`
	Or                  []BlobScalarWhereInput `json:"OR,omitempty"`
	Not                 []BlobScalarWhereInput `json:"NOT,omitempty"`
}

type BlobUpdateManyWithWhereNestedInput struct {
	Where BlobScalarWhereInput    `json:"where"`
	Data  BlobUpdateManyDataInput `json:"data"`
}

type BlobUpdateManyDataInput struct {
	Digest *string `json:"digest,omitempty"`
}

type ImageUpdateManyInput struct {
	Create     []ImageCreateInput                      `json:"create,omitempty"`
	Update     []ImageUpdateWithWhereUniqueNestedInput `json:"update,omitempty"`
	Upsert     []ImageUpsertWithWhereUniqueNestedInput `json:"upsert,omitempty"`
	Delete     []ImageWhereUniqueInput                 `json:"delete,omitempty"`
	Connect    []ImageWhereUniqueInput                 `json:"connect,omitempty"`
	Set        []ImageWhereUniqueInput                 `json:"set,omitempty"`
	Disconnect []ImageWhereUniqueInput                 `json:"disconnect,omitempty"`
	DeleteMany []ImageScalarWhereInput                 `json:"deleteMany,omitempty"`
	UpdateMany []ImageUpdateManyWithWhereNestedInput   `json:"updateMany,omitempty"`
}

type ImageUpdateWithWhereUniqueNestedInput struct {
	Where ImageWhereUniqueInput `json:"where"`
	Data  ImageUpdateDataInput  `json:"data"`
}

type ImageUpdateDataInput struct {
	Repo         *RepositoryUpdateOneRequiredInput `json:"repo,omitempty"`
	Digest       *string                           `json:"digest,omitempty"`
	Manifest     *map[string]interface{}           `json:"manifest,omitempty"`
	ManifestType *string                           `json:"manifest_type,omitempty"`
	Tags         *TagUpdateManyWithoutImageInput   `json:"tags,omitempty"`
}

type RepositoryUpdateOneRequiredInput struct {
	Create  *RepositoryCreateInput       `json:"create,omitempty"`
	Update  *RepositoryUpdateDataInput   `json:"update,omitempty"`
	Upsert  *RepositoryUpsertNestedInput `json:"upsert,omitempty"`
	Connect *RepositoryWhereUniqueInput  `json:"connect,omitempty"`
}

type RepositoryUpdateDataInput struct {
	Name  *string                                         `json:"name,omitempty"`
	Org   *OrganizationUpdateOneRequiredWithoutReposInput `json:"org,omitempty"`
	Blobs *BlobUpdateManyWithoutRepoInput                 `json:"blobs,omitempty"`
}

type BlobUpdateManyWithoutRepoInput struct {
	Create     []BlobCreateWithoutRepoInput                `json:"create,omitempty"`
	Delete     []BlobWhereUniqueInput                      `json:"delete,omitempty"`
	Connect    []BlobWhereUniqueInput                      `json:"connect,omitempty"`
	Set        []BlobWhereUniqueInput                      `json:"set,omitempty"`
	Disconnect []BlobWhereUniqueInput                      `json:"disconnect,omitempty"`
	Update     []BlobUpdateWithWhereUniqueWithoutRepoInput `json:"update,omitempty"`
	Upsert     []BlobUpsertWithWhereUniqueWithoutRepoInput `json:"upsert,omitempty"`
	DeleteMany []BlobScalarWhereInput                      `json:"deleteMany,omitempty"`
	UpdateMany []BlobUpdateManyWithWhereNestedInput        `json:"updateMany,omitempty"`
}

type BlobUpdateWithWhereUniqueWithoutRepoInput struct {
	Where BlobWhereUniqueInput           `json:"where"`
	Data  BlobUpdateWithoutRepoDataInput `json:"data"`
}

type BlobUpdateWithoutRepoDataInput struct {
	Digest *string `json:"digest,omitempty"`
}

type BlobUpsertWithWhereUniqueWithoutRepoInput struct {
	Where  BlobWhereUniqueInput           `json:"where"`
	Update BlobUpdateWithoutRepoDataInput `json:"update"`
	Create BlobCreateWithoutRepoInput     `json:"create"`
}

type RepositoryUpsertNestedInput struct {
	Update RepositoryUpdateDataInput `json:"update"`
	Create RepositoryCreateInput     `json:"create"`
}

type TagUpdateManyWithoutImageInput struct {
	Create     []TagCreateWithoutImageInput `json:"create,omitempty"`
	Delete     []TagWhereUniqueInput        `json:"delete,omitempty"`
	Connect    []TagWhereUniqueInput        `json:"connect,omitempty"`
	Set        []TagWhereUniqueInput        `json:"set,omitempty"`
	Disconnect []TagWhereUniqueInput        `json:"disconnect,omitempty"`
	DeleteMany []TagScalarWhereInput        `json:"deleteMany,omitempty"`
}

type TagScalarWhereInput struct {
	ID              *string               `json:"id,omitempty"`
	IDNot           *string               `json:"id_not,omitempty"`
	IDIn            []string              `json:"id_in,omitempty"`
	IDNotIn         []string              `json:"id_not_in,omitempty"`
	IDLt            *string               `json:"id_lt,omitempty"`
	IDLte           *string               `json:"id_lte,omitempty"`
	IDGt            *string               `json:"id_gt,omitempty"`
	IDGte           *string               `json:"id_gte,omitempty"`
	IDContains      *string               `json:"id_contains,omitempty"`
	IDNotContains   *string               `json:"id_not_contains,omitempty"`
	IDStartsWith    *string               `json:"id_starts_with,omitempty"`
	IDNotStartsWith *string               `json:"id_not_starts_with,omitempty"`
	IDEndsWith      *string               `json:"id_ends_with,omitempty"`
	IDNotEndsWith   *string               `json:"id_not_ends_with,omitempty"`
	CreatedAt       *string               `json:"createdAt,omitempty"`
	CreatedAtNot    *string               `json:"createdAt_not,omitempty"`
	CreatedAtIn     []string              `json:"createdAt_in,omitempty"`
	CreatedAtNotIn  []string              `json:"createdAt_not_in,omitempty"`
	CreatedAtLt     *string               `json:"createdAt_lt,omitempty"`
	CreatedAtLte    *string               `json:"createdAt_lte,omitempty"`
	CreatedAtGt     *string               `json:"createdAt_gt,omitempty"`
	CreatedAtGte    *string               `json:"createdAt_gte,omitempty"`
	UpdatedAt       *string               `json:"updatedAt,omitempty"`
	UpdatedAtNot    *string               `json:"updatedAt_not,omitempty"`
	UpdatedAtIn     []string              `json:"updatedAt_in,omitempty"`
	UpdatedAtNotIn  []string              `json:"updatedAt_not_in,omitempty"`
	UpdatedAtLt     *string               `json:"updatedAt_lt,omitempty"`
	UpdatedAtLte    *string               `json:"updatedAt_lte,omitempty"`
	UpdatedAtGt     *string               `json:"updatedAt_gt,omitempty"`
	UpdatedAtGte    *string               `json:"updatedAt_gte,omitempty"`
	And             []TagScalarWhereInput `json:"AND,omitempty"`
	Or              []TagScalarWhereInput `json:"OR,omitempty"`
	Not             []TagScalarWhereInput `json:"NOT,omitempty"`
}

type ImageUpsertWithWhereUniqueNestedInput struct {
	Where  ImageWhereUniqueInput `json:"where"`
	Update ImageUpdateDataInput  `json:"update"`
	Create ImageCreateInput      `json:"create"`
}

type ImageScalarWhereInput struct {
	ID                        *string                 `json:"id,omitempty"`
	IDNot                     *string                 `json:"id_not,omitempty"`
	IDIn                      []string                `json:"id_in,omitempty"`
	IDNotIn                   []string                `json:"id_not_in,omitempty"`
	IDLt                      *string                 `json:"id_lt,omitempty"`
	IDLte                     *string                 `json:"id_lte,omitempty"`
	IDGt                      *string                 `json:"id_gt,omitempty"`
	IDGte                     *string                 `json:"id_gte,omitempty"`
	IDContains                *string                 `json:"id_contains,omitempty"`
	IDNotContains             *string                 `json:"id_not_contains,omitempty"`
	IDStartsWith              *string                 `json:"id_starts_with,omitempty"`
	IDNotStartsWith           *string                 `json:"id_not_starts_with,omitempty"`
	IDEndsWith                *string                 `json:"id_ends_with,omitempty"`
	IDNotEndsWith             *string                 `json:"id_not_ends_with,omitempty"`
	CreatedAt                 *string                 `json:"createdAt,omitempty"`
	CreatedAtNot              *string                 `json:"createdAt_not,omitempty"`
	CreatedAtIn               []string                `json:"createdAt_in,omitempty"`
	CreatedAtNotIn            []string                `json:"createdAt_not_in,omitempty"`
	CreatedAtLt               *string                 `json:"createdAt_lt,omitempty"`
	CreatedAtLte              *string                 `json:"createdAt_lte,omitempty"`
	CreatedAtGt               *string                 `json:"createdAt_gt,omitempty"`
	CreatedAtGte              *string                 `json:"createdAt_gte,omitempty"`
	UpdatedAt                 *string                 `json:"updatedAt,omitempty"`
	UpdatedAtNot              *string                 `json:"updatedAt_not,omitempty"`
	UpdatedAtIn               []string                `json:"updatedAt_in,omitempty"`
	UpdatedAtNotIn            []string                `json:"updatedAt_not_in,omitempty"`
	UpdatedAtLt               *string                 `json:"updatedAt_lt,omitempty"`
	UpdatedAtLte              *string                 `json:"updatedAt_lte,omitempty"`
	UpdatedAtGt               *string                 `json:"updatedAt_gt,omitempty"`
	UpdatedAtGte              *string                 `json:"updatedAt_gte,omitempty"`
	Digest                    *string                 `json:"digest,omitempty"`
	DigestNot                 *string                 `json:"digest_not,omitempty"`
	DigestIn                  []string                `json:"digest_in,omitempty"`
	DigestNotIn               []string                `json:"digest_not_in,omitempty"`
	DigestLt                  *string                 `json:"digest_lt,omitempty"`
	DigestLte                 *string                 `json:"digest_lte,omitempty"`
	DigestGt                  *string                 `json:"digest_gt,omitempty"`
	DigestGte                 *string                 `json:"digest_gte,omitempty"`
	DigestContains            *string                 `json:"digest_contains,omitempty"`
	DigestNotContains         *string                 `json:"digest_not_contains,omitempty"`
	DigestStartsWith          *string                 `json:"digest_starts_with,omitempty"`
	DigestNotStartsWith       *string                 `json:"digest_not_starts_with,omitempty"`
	DigestEndsWith            *string                 `json:"digest_ends_with,omitempty"`
	DigestNotEndsWith         *string                 `json:"digest_not_ends_with,omitempty"`
	ManifestType              *string                 `json:"manifest_type,omitempty"`
	ManifestTypeNot           *string                 `json:"manifest_type_not,omitempty"`
	ManifestTypeIn            []string                `json:"manifest_type_in,omitempty"`
	ManifestTypeNotIn         []string                `json:"manifest_type_not_in,omitempty"`
	ManifestTypeLt            *string                 `json:"manifest_type_lt,omitempty"`
	ManifestTypeLte           *string                 `json:"manifest_type_lte,omitempty"`
	ManifestTypeGt            *string                 `json:"manifest_type_gt,omitempty"`
	ManifestTypeGte           *string                 `json:"manifest_type_gte,omitempty"`
	ManifestTypeContains      *string                 `json:"manifest_type_contains,omitempty"`
	ManifestTypeNotContains   *string                 `json:"manifest_type_not_contains,omitempty"`
	ManifestTypeStartsWith    *string                 `json:"manifest_type_starts_with,omitempty"`
	ManifestTypeNotStartsWith *string                 `json:"manifest_type_not_starts_with,omitempty"`
	ManifestTypeEndsWith      *string                 `json:"manifest_type_ends_with,omitempty"`
	ManifestTypeNotEndsWith   *string                 `json:"manifest_type_not_ends_with,omitempty"`
	And                       []ImageScalarWhereInput `json:"AND,omitempty"`
	Or                        []ImageScalarWhereInput `json:"OR,omitempty"`
	Not                       []ImageScalarWhereInput `json:"NOT,omitempty"`
}

type ImageUpdateManyWithWhereNestedInput struct {
	Where ImageScalarWhereInput    `json:"where"`
	Data  ImageUpdateManyDataInput `json:"data"`
}

type ImageUpdateManyDataInput struct {
	Digest       *string                 `json:"digest,omitempty"`
	Manifest     *map[string]interface{} `json:"manifest,omitempty"`
	ManifestType *string                 `json:"manifest_type,omitempty"`
}

type OrganizationUpsertWithoutReposInput struct {
	Update OrganizationUpdateWithoutReposDataInput `json:"update"`
	Create OrganizationCreateWithoutReposInput     `json:"create"`
}

type RepositoryUpsertWithoutBlobsInput struct {
	Update RepositoryUpdateWithoutBlobsDataInput `json:"update"`
	Create RepositoryCreateWithoutBlobsInput     `json:"create"`
}

type BlobUpdateManyMutationInput struct {
	Digest *string `json:"digest,omitempty"`
}

type ChunkCreateInput struct {
	ID         *string                           `json:"id,omitempty"`
	Upload     UploadCreateOneWithoutChunksInput `json:"upload"`
	RangeStart *int32                            `json:"rangeStart,omitempty"`
	RangeEnd   *int32                            `json:"rangeEnd,omitempty"`
}

type UploadCreateOneWithoutChunksInput struct {
	Create  *UploadCreateWithoutChunksInput `json:"create,omitempty"`
	Connect *UploadWhereUniqueInput         `json:"connect,omitempty"`
}

type UploadCreateWithoutChunksInput struct {
	ID   *string `json:"id,omitempty"`
	Uuid string  `json:"uuid"`
	Done *bool   `json:"done,omitempty"`
}

type ChunkUpdateInput struct {
	Upload     *UploadUpdateOneRequiredWithoutChunksInput `json:"upload,omitempty"`
	RangeStart *int32                                     `json:"rangeStart,omitempty"`
	RangeEnd   *int32                                     `json:"rangeEnd,omitempty"`
}

type UploadUpdateOneRequiredWithoutChunksInput struct {
	Create  *UploadCreateWithoutChunksInput     `json:"create,omitempty"`
	Update  *UploadUpdateWithoutChunksDataInput `json:"update,omitempty"`
	Upsert  *UploadUpsertWithoutChunksInput     `json:"upsert,omitempty"`
	Connect *UploadWhereUniqueInput             `json:"connect,omitempty"`
}

type UploadUpdateWithoutChunksDataInput struct {
	Uuid *string `json:"uuid,omitempty"`
	Done *bool   `json:"done,omitempty"`
}

type UploadUpsertWithoutChunksInput struct {
	Update UploadUpdateWithoutChunksDataInput `json:"update"`
	Create UploadCreateWithoutChunksInput     `json:"create"`
}

type ChunkUpdateManyMutationInput struct {
	RangeStart *int32 `json:"rangeStart,omitempty"`
	RangeEnd   *int32 `json:"rangeEnd,omitempty"`
}

type ImageUpdateInput struct {
	Repo         *RepositoryUpdateOneRequiredInput `json:"repo,omitempty"`
	Digest       *string                           `json:"digest,omitempty"`
	Manifest     *map[string]interface{}           `json:"manifest,omitempty"`
	ManifestType *string                           `json:"manifest_type,omitempty"`
	Tags         *TagUpdateManyWithoutImageInput   `json:"tags,omitempty"`
}

type ImageUpdateManyMutationInput struct {
	Digest       *string                 `json:"digest,omitempty"`
	Manifest     *map[string]interface{} `json:"manifest,omitempty"`
	ManifestType *string                 `json:"manifest_type,omitempty"`
}

type OrganizationCreateInput struct {
	ID     *string                              `json:"id,omitempty"`
	Name   string                               `json:"name"`
	Repos  *RepositoryCreateManyWithoutOrgInput `json:"repos,omitempty"`
	Blobs  *BlobCreateManyInput                 `json:"blobs,omitempty"`
	Images *ImageCreateManyInput                `json:"images,omitempty"`
}

type RepositoryCreateManyWithoutOrgInput struct {
	Create  []RepositoryCreateWithoutOrgInput `json:"create,omitempty"`
	Connect []RepositoryWhereUniqueInput      `json:"connect,omitempty"`
}

type RepositoryCreateWithoutOrgInput struct {
	ID    *string                         `json:"id,omitempty"`
	Name  string                          `json:"name"`
	Blobs *BlobCreateManyWithoutRepoInput `json:"blobs,omitempty"`
}

type OrganizationUpdateInput struct {
	Name   *string                              `json:"name,omitempty"`
	Repos  *RepositoryUpdateManyWithoutOrgInput `json:"repos,omitempty"`
	Blobs  *BlobUpdateManyInput                 `json:"blobs,omitempty"`
	Images *ImageUpdateManyInput                `json:"images,omitempty"`
}

type RepositoryUpdateManyWithoutOrgInput struct {
	Create     []RepositoryCreateWithoutOrgInput                `json:"create,omitempty"`
	Delete     []RepositoryWhereUniqueInput                     `json:"delete,omitempty"`
	Connect    []RepositoryWhereUniqueInput                     `json:"connect,omitempty"`
	Set        []RepositoryWhereUniqueInput                     `json:"set,omitempty"`
	Disconnect []RepositoryWhereUniqueInput                     `json:"disconnect,omitempty"`
	Update     []RepositoryUpdateWithWhereUniqueWithoutOrgInput `json:"update,omitempty"`
	Upsert     []RepositoryUpsertWithWhereUniqueWithoutOrgInput `json:"upsert,omitempty"`
	DeleteMany []RepositoryScalarWhereInput                     `json:"deleteMany,omitempty"`
	UpdateMany []RepositoryUpdateManyWithWhereNestedInput       `json:"updateMany,omitempty"`
}

type RepositoryUpdateWithWhereUniqueWithoutOrgInput struct {
	Where RepositoryWhereUniqueInput          `json:"where"`
	Data  RepositoryUpdateWithoutOrgDataInput `json:"data"`
}

type RepositoryUpdateWithoutOrgDataInput struct {
	Name  *string                         `json:"name,omitempty"`
	Blobs *BlobUpdateManyWithoutRepoInput `json:"blobs,omitempty"`
}

type RepositoryUpsertWithWhereUniqueWithoutOrgInput struct {
	Where  RepositoryWhereUniqueInput          `json:"where"`
	Update RepositoryUpdateWithoutOrgDataInput `json:"update"`
	Create RepositoryCreateWithoutOrgInput     `json:"create"`
}

type RepositoryScalarWhereInput struct {
	ID                *string                      `json:"id,omitempty"`
	IDNot             *string                      `json:"id_not,omitempty"`
	IDIn              []string                     `json:"id_in,omitempty"`
	IDNotIn           []string                     `json:"id_not_in,omitempty"`
	IDLt              *string                      `json:"id_lt,omitempty"`
	IDLte             *string                      `json:"id_lte,omitempty"`
	IDGt              *string                      `json:"id_gt,omitempty"`
	IDGte             *string                      `json:"id_gte,omitempty"`
	IDContains        *string                      `json:"id_contains,omitempty"`
	IDNotContains     *string                      `json:"id_not_contains,omitempty"`
	IDStartsWith      *string                      `json:"id_starts_with,omitempty"`
	IDNotStartsWith   *string                      `json:"id_not_starts_with,omitempty"`
	IDEndsWith        *string                      `json:"id_ends_with,omitempty"`
	IDNotEndsWith     *string                      `json:"id_not_ends_with,omitempty"`
	CreatedAt         *string                      `json:"createdAt,omitempty"`
	CreatedAtNot      *string                      `json:"createdAt_not,omitempty"`
	CreatedAtIn       []string                     `json:"createdAt_in,omitempty"`
	CreatedAtNotIn    []string                     `json:"createdAt_not_in,omitempty"`
	CreatedAtLt       *string                      `json:"createdAt_lt,omitempty"`
	CreatedAtLte      *string                      `json:"createdAt_lte,omitempty"`
	CreatedAtGt       *string                      `json:"createdAt_gt,omitempty"`
	CreatedAtGte      *string                      `json:"createdAt_gte,omitempty"`
	UpdatedAt         *string                      `json:"updatedAt,omitempty"`
	UpdatedAtNot      *string                      `json:"updatedAt_not,omitempty"`
	UpdatedAtIn       []string                     `json:"updatedAt_in,omitempty"`
	UpdatedAtNotIn    []string                     `json:"updatedAt_not_in,omitempty"`
	UpdatedAtLt       *string                      `json:"updatedAt_lt,omitempty"`
	UpdatedAtLte      *string                      `json:"updatedAt_lte,omitempty"`
	UpdatedAtGt       *string                      `json:"updatedAt_gt,omitempty"`
	UpdatedAtGte      *string                      `json:"updatedAt_gte,omitempty"`
	Name              *string                      `json:"name,omitempty"`
	NameNot           *string                      `json:"name_not,omitempty"`
	NameIn            []string                     `json:"name_in,omitempty"`
	NameNotIn         []string                     `json:"name_not_in,omitempty"`
	NameLt            *string                      `json:"name_lt,omitempty"`
	NameLte           *string                      `json:"name_lte,omitempty"`
	NameGt            *string                      `json:"name_gt,omitempty"`
	NameGte           *string                      `json:"name_gte,omitempty"`
	NameContains      *string                      `json:"name_contains,omitempty"`
	NameNotContains   *string                      `json:"name_not_contains,omitempty"`
	NameStartsWith    *string                      `json:"name_starts_with,omitempty"`
	NameNotStartsWith *string                      `json:"name_not_starts_with,omitempty"`
	NameEndsWith      *string                      `json:"name_ends_with,omitempty"`
	NameNotEndsWith   *string                      `json:"name_not_ends_with,omitempty"`
	And               []RepositoryScalarWhereInput `json:"AND,omitempty"`
	Or                []RepositoryScalarWhereInput `json:"OR,omitempty"`
	Not               []RepositoryScalarWhereInput `json:"NOT,omitempty"`
}

type RepositoryUpdateManyWithWhereNestedInput struct {
	Where RepositoryScalarWhereInput    `json:"where"`
	Data  RepositoryUpdateManyDataInput `json:"data"`
}

type RepositoryUpdateManyDataInput struct {
	Name *string `json:"name,omitempty"`
}

type OrganizationUpdateManyMutationInput struct {
	Name *string `json:"name,omitempty"`
}

type RepositoryUpdateInput struct {
	Name  *string                                         `json:"name,omitempty"`
	Org   *OrganizationUpdateOneRequiredWithoutReposInput `json:"org,omitempty"`
	Blobs *BlobUpdateManyWithoutRepoInput                 `json:"blobs,omitempty"`
}

type RepositoryUpdateManyMutationInput struct {
	Name *string `json:"name,omitempty"`
}

type TagCreateInput struct {
	ID    *string                        `json:"id,omitempty"`
	Image ImageCreateOneWithoutTagsInput `json:"image"`
}

type ImageCreateOneWithoutTagsInput struct {
	Create  *ImageCreateWithoutTagsInput `json:"create,omitempty"`
	Connect *ImageWhereUniqueInput       `json:"connect,omitempty"`
}

type ImageCreateWithoutTagsInput struct {
	ID           *string                  `json:"id,omitempty"`
	Repo         RepositoryCreateOneInput `json:"repo"`
	Digest       string                   `json:"digest"`
	Manifest     map[string]interface{}   `json:"manifest"`
	ManifestType string                   `json:"manifest_type"`
}

type TagUpdateInput struct {
	Image *ImageUpdateOneRequiredWithoutTagsInput `json:"image,omitempty"`
}

type ImageUpdateOneRequiredWithoutTagsInput struct {
	Create  *ImageCreateWithoutTagsInput     `json:"create,omitempty"`
	Update  *ImageUpdateWithoutTagsDataInput `json:"update,omitempty"`
	Upsert  *ImageUpsertWithoutTagsInput     `json:"upsert,omitempty"`
	Connect *ImageWhereUniqueInput           `json:"connect,omitempty"`
}

type ImageUpdateWithoutTagsDataInput struct {
	Repo         *RepositoryUpdateOneRequiredInput `json:"repo,omitempty"`
	Digest       *string                           `json:"digest,omitempty"`
	Manifest     *map[string]interface{}           `json:"manifest,omitempty"`
	ManifestType *string                           `json:"manifest_type,omitempty"`
}

type ImageUpsertWithoutTagsInput struct {
	Update ImageUpdateWithoutTagsDataInput `json:"update"`
	Create ImageCreateWithoutTagsInput     `json:"create"`
}

type UploadCreateInput struct {
	ID     *string                            `json:"id,omitempty"`
	Uuid   string                             `json:"uuid"`
	Done   *bool                              `json:"done,omitempty"`
	Chunks *ChunkCreateManyWithoutUploadInput `json:"chunks,omitempty"`
}

type ChunkCreateManyWithoutUploadInput struct {
	Create  []ChunkCreateWithoutUploadInput `json:"create,omitempty"`
	Connect []ChunkWhereUniqueInput         `json:"connect,omitempty"`
}

type ChunkCreateWithoutUploadInput struct {
	ID         *string `json:"id,omitempty"`
	RangeStart *int32  `json:"rangeStart,omitempty"`
	RangeEnd   *int32  `json:"rangeEnd,omitempty"`
}

type UploadUpdateInput struct {
	Uuid   *string                            `json:"uuid,omitempty"`
	Done   *bool                              `json:"done,omitempty"`
	Chunks *ChunkUpdateManyWithoutUploadInput `json:"chunks,omitempty"`
}

type ChunkUpdateManyWithoutUploadInput struct {
	Create     []ChunkCreateWithoutUploadInput                `json:"create,omitempty"`
	Delete     []ChunkWhereUniqueInput                        `json:"delete,omitempty"`
	Connect    []ChunkWhereUniqueInput                        `json:"connect,omitempty"`
	Set        []ChunkWhereUniqueInput                        `json:"set,omitempty"`
	Disconnect []ChunkWhereUniqueInput                        `json:"disconnect,omitempty"`
	Update     []ChunkUpdateWithWhereUniqueWithoutUploadInput `json:"update,omitempty"`
	Upsert     []ChunkUpsertWithWhereUniqueWithoutUploadInput `json:"upsert,omitempty"`
	DeleteMany []ChunkScalarWhereInput                        `json:"deleteMany,omitempty"`
	UpdateMany []ChunkUpdateManyWithWhereNestedInput          `json:"updateMany,omitempty"`
}

type ChunkUpdateWithWhereUniqueWithoutUploadInput struct {
	Where ChunkWhereUniqueInput             `json:"where"`
	Data  ChunkUpdateWithoutUploadDataInput `json:"data"`
}

type ChunkUpdateWithoutUploadDataInput struct {
	RangeStart *int32 `json:"rangeStart,omitempty"`
	RangeEnd   *int32 `json:"rangeEnd,omitempty"`
}

type ChunkUpsertWithWhereUniqueWithoutUploadInput struct {
	Where  ChunkWhereUniqueInput             `json:"where"`
	Update ChunkUpdateWithoutUploadDataInput `json:"update"`
	Create ChunkCreateWithoutUploadInput     `json:"create"`
}

type ChunkScalarWhereInput struct {
	ID              *string                 `json:"id,omitempty"`
	IDNot           *string                 `json:"id_not,omitempty"`
	IDIn            []string                `json:"id_in,omitempty"`
	IDNotIn         []string                `json:"id_not_in,omitempty"`
	IDLt            *string                 `json:"id_lt,omitempty"`
	IDLte           *string                 `json:"id_lte,omitempty"`
	IDGt            *string                 `json:"id_gt,omitempty"`
	IDGte           *string                 `json:"id_gte,omitempty"`
	IDContains      *string                 `json:"id_contains,omitempty"`
	IDNotContains   *string                 `json:"id_not_contains,omitempty"`
	IDStartsWith    *string                 `json:"id_starts_with,omitempty"`
	IDNotStartsWith *string                 `json:"id_not_starts_with,omitempty"`
	IDEndsWith      *string                 `json:"id_ends_with,omitempty"`
	IDNotEndsWith   *string                 `json:"id_not_ends_with,omitempty"`
	CreatedAt       *string                 `json:"createdAt,omitempty"`
	CreatedAtNot    *string                 `json:"createdAt_not,omitempty"`
	CreatedAtIn     []string                `json:"createdAt_in,omitempty"`
	CreatedAtNotIn  []string                `json:"createdAt_not_in,omitempty"`
	CreatedAtLt     *string                 `json:"createdAt_lt,omitempty"`
	CreatedAtLte    *string                 `json:"createdAt_lte,omitempty"`
	CreatedAtGt     *string                 `json:"createdAt_gt,omitempty"`
	CreatedAtGte    *string                 `json:"createdAt_gte,omitempty"`
	UpdatedAt       *string                 `json:"updatedAt,omitempty"`
	UpdatedAtNot    *string                 `json:"updatedAt_not,omitempty"`
	UpdatedAtIn     []string                `json:"updatedAt_in,omitempty"`
	UpdatedAtNotIn  []string                `json:"updatedAt_not_in,omitempty"`
	UpdatedAtLt     *string                 `json:"updatedAt_lt,omitempty"`
	UpdatedAtLte    *string                 `json:"updatedAt_lte,omitempty"`
	UpdatedAtGt     *string                 `json:"updatedAt_gt,omitempty"`
	UpdatedAtGte    *string                 `json:"updatedAt_gte,omitempty"`
	RangeStart      *int32                  `json:"rangeStart,omitempty"`
	RangeStartNot   *int32                  `json:"rangeStart_not,omitempty"`
	RangeStartIn    []int32                 `json:"rangeStart_in,omitempty"`
	RangeStartNotIn []int32                 `json:"rangeStart_not_in,omitempty"`
	RangeStartLt    *int32                  `json:"rangeStart_lt,omitempty"`
	RangeStartLte   *int32                  `json:"rangeStart_lte,omitempty"`
	RangeStartGt    *int32                  `json:"rangeStart_gt,omitempty"`
	RangeStartGte   *int32                  `json:"rangeStart_gte,omitempty"`
	RangeEnd        *int32                  `json:"rangeEnd,omitempty"`
	RangeEndNot     *int32                  `json:"rangeEnd_not,omitempty"`
	RangeEndIn      []int32                 `json:"rangeEnd_in,omitempty"`
	RangeEndNotIn   []int32                 `json:"rangeEnd_not_in,omitempty"`
	RangeEndLt      *int32                  `json:"rangeEnd_lt,omitempty"`
	RangeEndLte     *int32                  `json:"rangeEnd_lte,omitempty"`
	RangeEndGt      *int32                  `json:"rangeEnd_gt,omitempty"`
	RangeEndGte     *int32                  `json:"rangeEnd_gte,omitempty"`
	And             []ChunkScalarWhereInput `json:"AND,omitempty"`
	Or              []ChunkScalarWhereInput `json:"OR,omitempty"`
	Not             []ChunkScalarWhereInput `json:"NOT,omitempty"`
}

type ChunkUpdateManyWithWhereNestedInput struct {
	Where ChunkScalarWhereInput    `json:"where"`
	Data  ChunkUpdateManyDataInput `json:"data"`
}

type ChunkUpdateManyDataInput struct {
	RangeStart *int32 `json:"rangeStart,omitempty"`
	RangeEnd   *int32 `json:"rangeEnd,omitempty"`
}

type UploadUpdateManyMutationInput struct {
	Uuid *string `json:"uuid,omitempty"`
	Done *bool   `json:"done,omitempty"`
}

type BlobSubscriptionWhereInput struct {
	MutationIn                 []MutationType               `json:"mutation_in,omitempty"`
	UpdatedFieldsContains      *string                      `json:"updatedFields_contains,omitempty"`
	UpdatedFieldsContainsEvery []string                     `json:"updatedFields_contains_every,omitempty"`
	UpdatedFieldsContainsSome  []string                     `json:"updatedFields_contains_some,omitempty"`
	Node                       *BlobWhereInput              `json:"node,omitempty"`
	And                        []BlobSubscriptionWhereInput `json:"AND,omitempty"`
	Or                         []BlobSubscriptionWhereInput `json:"OR,omitempty"`
	Not                        []BlobSubscriptionWhereInput `json:"NOT,omitempty"`
}

type ChunkSubscriptionWhereInput struct {
	MutationIn                 []MutationType                `json:"mutation_in,omitempty"`
	UpdatedFieldsContains      *string                       `json:"updatedFields_contains,omitempty"`
	UpdatedFieldsContainsEvery []string                      `json:"updatedFields_contains_every,omitempty"`
	UpdatedFieldsContainsSome  []string                      `json:"updatedFields_contains_some,omitempty"`
	Node                       *ChunkWhereInput              `json:"node,omitempty"`
	And                        []ChunkSubscriptionWhereInput `json:"AND,omitempty"`
	Or                         []ChunkSubscriptionWhereInput `json:"OR,omitempty"`
	Not                        []ChunkSubscriptionWhereInput `json:"NOT,omitempty"`
}

type ImageSubscriptionWhereInput struct {
	MutationIn                 []MutationType                `json:"mutation_in,omitempty"`
	UpdatedFieldsContains      *string                       `json:"updatedFields_contains,omitempty"`
	UpdatedFieldsContainsEvery []string                      `json:"updatedFields_contains_every,omitempty"`
	UpdatedFieldsContainsSome  []string                      `json:"updatedFields_contains_some,omitempty"`
	Node                       *ImageWhereInput              `json:"node,omitempty"`
	And                        []ImageSubscriptionWhereInput `json:"AND,omitempty"`
	Or                         []ImageSubscriptionWhereInput `json:"OR,omitempty"`
	Not                        []ImageSubscriptionWhereInput `json:"NOT,omitempty"`
}

type OrganizationSubscriptionWhereInput struct {
	MutationIn                 []MutationType                       `json:"mutation_in,omitempty"`
	UpdatedFieldsContains      *string                              `json:"updatedFields_contains,omitempty"`
	UpdatedFieldsContainsEvery []string                             `json:"updatedFields_contains_every,omitempty"`
	UpdatedFieldsContainsSome  []string                             `json:"updatedFields_contains_some,omitempty"`
	Node                       *OrganizationWhereInput              `json:"node,omitempty"`
	And                        []OrganizationSubscriptionWhereInput `json:"AND,omitempty"`
	Or                         []OrganizationSubscriptionWhereInput `json:"OR,omitempty"`
	Not                        []OrganizationSubscriptionWhereInput `json:"NOT,omitempty"`
}

type RepositorySubscriptionWhereInput struct {
	MutationIn                 []MutationType                     `json:"mutation_in,omitempty"`
	UpdatedFieldsContains      *string                            `json:"updatedFields_contains,omitempty"`
	UpdatedFieldsContainsEvery []string                           `json:"updatedFields_contains_every,omitempty"`
	UpdatedFieldsContainsSome  []string                           `json:"updatedFields_contains_some,omitempty"`
	Node                       *RepositoryWhereInput              `json:"node,omitempty"`
	And                        []RepositorySubscriptionWhereInput `json:"AND,omitempty"`
	Or                         []RepositorySubscriptionWhereInput `json:"OR,omitempty"`
	Not                        []RepositorySubscriptionWhereInput `json:"NOT,omitempty"`
}

type TagSubscriptionWhereInput struct {
	MutationIn                 []MutationType              `json:"mutation_in,omitempty"`
	UpdatedFieldsContains      *string                     `json:"updatedFields_contains,omitempty"`
	UpdatedFieldsContainsEvery []string                    `json:"updatedFields_contains_every,omitempty"`
	UpdatedFieldsContainsSome  []string                    `json:"updatedFields_contains_some,omitempty"`
	Node                       *TagWhereInput              `json:"node,omitempty"`
	And                        []TagSubscriptionWhereInput `json:"AND,omitempty"`
	Or                         []TagSubscriptionWhereInput `json:"OR,omitempty"`
	Not                        []TagSubscriptionWhereInput `json:"NOT,omitempty"`
}

type UploadSubscriptionWhereInput struct {
	MutationIn                 []MutationType                 `json:"mutation_in,omitempty"`
	UpdatedFieldsContains      *string                        `json:"updatedFields_contains,omitempty"`
	UpdatedFieldsContainsEvery []string                       `json:"updatedFields_contains_every,omitempty"`
	UpdatedFieldsContainsSome  []string                       `json:"updatedFields_contains_some,omitempty"`
	Node                       *UploadWhereInput              `json:"node,omitempty"`
	And                        []UploadSubscriptionWhereInput `json:"AND,omitempty"`
	Or                         []UploadSubscriptionWhereInput `json:"OR,omitempty"`
	Not                        []UploadSubscriptionWhereInput `json:"NOT,omitempty"`
}

type BlobExec struct {
	exec *prisma.Exec
}

func (instance *BlobExec) Repo() *RepositoryExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Repository"},
		"repo",
		[]string{"id", "createdAt", "updatedAt", "name"})

	return &RepositoryExec{ret}
}

func (instance BlobExec) Exec(ctx context.Context) (*Blob, error) {
	var v Blob
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance BlobExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type BlobExecArray struct {
	exec *prisma.Exec
}

func (instance BlobExecArray) Exec(ctx context.Context) ([]Blob, error) {
	var v []Blob
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type Blob struct {
	ID        string `json:"id"`
	CreatedAt string `json:"createdAt"`
	UpdatedAt string `json:"updatedAt"`
	Digest    string `json:"digest"`
}

type RepositoryExec struct {
	exec *prisma.Exec
}

func (instance *RepositoryExec) Org() *OrganizationExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Organization"},
		"org",
		[]string{"id", "createdAt", "updatedAt", "name"})

	return &OrganizationExec{ret}
}

type BlobsParamsExec struct {
	Where   *BlobWhereInput
	OrderBy *BlobOrderByInput
	Skip    *int32
	After   *string
	Before  *string
	First   *int32
	Last    *int32
}

func (instance *RepositoryExec) Blobs(params *BlobsParamsExec) *BlobExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := instance.exec.Client.GetMany(
		instance.exec,
		wparams,
		[3]string{"BlobWhereInput", "BlobOrderByInput", "Blob"},
		"blobs",
		[]string{"id", "createdAt", "updatedAt", "digest"})

	return &BlobExecArray{ret}
}

func (instance RepositoryExec) Exec(ctx context.Context) (*Repository, error) {
	var v Repository
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance RepositoryExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type RepositoryExecArray struct {
	exec *prisma.Exec
}

func (instance RepositoryExecArray) Exec(ctx context.Context) ([]Repository, error) {
	var v []Repository
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type Repository struct {
	ID        string `json:"id"`
	CreatedAt string `json:"createdAt"`
	UpdatedAt string `json:"updatedAt"`
	Name      string `json:"name"`
}

type OrganizationExec struct {
	exec *prisma.Exec
}

type ReposParamsExec struct {
	Where   *RepositoryWhereInput
	OrderBy *RepositoryOrderByInput
	Skip    *int32
	After   *string
	Before  *string
	First   *int32
	Last    *int32
}

func (instance *OrganizationExec) Repos(params *ReposParamsExec) *RepositoryExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := instance.exec.Client.GetMany(
		instance.exec,
		wparams,
		[3]string{"RepositoryWhereInput", "RepositoryOrderByInput", "Repository"},
		"repos",
		[]string{"id", "createdAt", "updatedAt", "name"})

	return &RepositoryExecArray{ret}
}

func (instance *OrganizationExec) Blobs(params *BlobsParamsExec) *BlobExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := instance.exec.Client.GetMany(
		instance.exec,
		wparams,
		[3]string{"BlobWhereInput", "BlobOrderByInput", "Blob"},
		"blobs",
		[]string{"id", "createdAt", "updatedAt", "digest"})

	return &BlobExecArray{ret}
}

type ImagesParamsExec struct {
	Where   *ImageWhereInput
	OrderBy *ImageOrderByInput
	Skip    *int32
	After   *string
	Before  *string
	First   *int32
	Last    *int32
}

func (instance *OrganizationExec) Images(params *ImagesParamsExec) *ImageExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := instance.exec.Client.GetMany(
		instance.exec,
		wparams,
		[3]string{"ImageWhereInput", "ImageOrderByInput", "Image"},
		"images",
		[]string{"id", "createdAt", "updatedAt", "digest", "manifest", "manifest_type"})

	return &ImageExecArray{ret}
}

func (instance OrganizationExec) Exec(ctx context.Context) (*Organization, error) {
	var v Organization
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance OrganizationExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type OrganizationExecArray struct {
	exec *prisma.Exec
}

func (instance OrganizationExecArray) Exec(ctx context.Context) ([]Organization, error) {
	var v []Organization
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type Organization struct {
	ID        string `json:"id"`
	CreatedAt string `json:"createdAt"`
	UpdatedAt string `json:"updatedAt"`
	Name      string `json:"name"`
}

type ImageExec struct {
	exec *prisma.Exec
}

func (instance *ImageExec) Repo() *RepositoryExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Repository"},
		"repo",
		[]string{"id", "createdAt", "updatedAt", "name"})

	return &RepositoryExec{ret}
}

type TagsParamsExec struct {
	Where   *TagWhereInput
	OrderBy *TagOrderByInput
	Skip    *int32
	After   *string
	Before  *string
	First   *int32
	Last    *int32
}

func (instance *ImageExec) Tags(params *TagsParamsExec) *TagExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := instance.exec.Client.GetMany(
		instance.exec,
		wparams,
		[3]string{"TagWhereInput", "TagOrderByInput", "Tag"},
		"tags",
		[]string{"id", "createdAt", "updatedAt"})

	return &TagExecArray{ret}
}

func (instance ImageExec) Exec(ctx context.Context) (*Image, error) {
	var v Image
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance ImageExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type ImageExecArray struct {
	exec *prisma.Exec
}

func (instance ImageExecArray) Exec(ctx context.Context) ([]Image, error) {
	var v []Image
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type Image struct {
	ID           string                 `json:"id"`
	CreatedAt    string                 `json:"createdAt"`
	UpdatedAt    string                 `json:"updatedAt"`
	Digest       string                 `json:"digest"`
	Manifest     map[string]interface{} `json:"manifest"`
	ManifestType string                 `json:"manifest_type"`
}

type TagExec struct {
	exec *prisma.Exec
}

func (instance *TagExec) Image() *ImageExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Image"},
		"image",
		[]string{"id", "createdAt", "updatedAt", "digest", "manifest", "manifest_type"})

	return &ImageExec{ret}
}

func (instance TagExec) Exec(ctx context.Context) (*Tag, error) {
	var v Tag
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance TagExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type TagExecArray struct {
	exec *prisma.Exec
}

func (instance TagExecArray) Exec(ctx context.Context) ([]Tag, error) {
	var v []Tag
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type Tag struct {
	ID        string `json:"id"`
	CreatedAt string `json:"createdAt"`
	UpdatedAt string `json:"updatedAt"`
}

type BlobConnectionExec struct {
	exec *prisma.Exec
}

func (instance *BlobConnectionExec) PageInfo() *PageInfoExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PageInfo"},
		"pageInfo",
		[]string{"hasNextPage", "hasPreviousPage", "startCursor", "endCursor"})

	return &PageInfoExec{ret}
}

func (instance *BlobConnectionExec) Edges() *BlobEdgeExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "BlobEdge"},
		"edges",
		[]string{"cursor"})

	return &BlobEdgeExec{ret}
}

func (instance *BlobConnectionExec) Aggregate(ctx context.Context) (Aggregate, error) {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AggregateBlob"},
		"aggregate",
		[]string{"count"})

	var v Aggregate
	_, err := ret.Exec(ctx, &v)
	return v, err
}

func (instance BlobConnectionExec) Exec(ctx context.Context) (*BlobConnection, error) {
	var v BlobConnection
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance BlobConnectionExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type BlobConnectionExecArray struct {
	exec *prisma.Exec
}

func (instance BlobConnectionExecArray) Exec(ctx context.Context) ([]BlobConnection, error) {
	var v []BlobConnection
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type BlobConnection struct {
}

type PageInfoExec struct {
	exec *prisma.Exec
}

func (instance PageInfoExec) Exec(ctx context.Context) (*PageInfo, error) {
	var v PageInfo
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance PageInfoExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type PageInfoExecArray struct {
	exec *prisma.Exec
}

func (instance PageInfoExecArray) Exec(ctx context.Context) ([]PageInfo, error) {
	var v []PageInfo
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type PageInfo struct {
	HasNextPage     bool    `json:"hasNextPage"`
	HasPreviousPage bool    `json:"hasPreviousPage"`
	StartCursor     *string `json:"startCursor,omitempty"`
	EndCursor       *string `json:"endCursor,omitempty"`
}

type BlobEdgeExec struct {
	exec *prisma.Exec
}

func (instance *BlobEdgeExec) Node() *BlobExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Blob"},
		"node",
		[]string{"id", "createdAt", "updatedAt", "digest"})

	return &BlobExec{ret}
}

func (instance BlobEdgeExec) Exec(ctx context.Context) (*BlobEdge, error) {
	var v BlobEdge
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance BlobEdgeExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type BlobEdgeExecArray struct {
	exec *prisma.Exec
}

func (instance BlobEdgeExecArray) Exec(ctx context.Context) ([]BlobEdge, error) {
	var v []BlobEdge
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type BlobEdge struct {
	Cursor string `json:"cursor"`
}

type ChunkExec struct {
	exec *prisma.Exec
}

func (instance *ChunkExec) Upload() *UploadExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Upload"},
		"upload",
		[]string{"id", "createdAt", "updatedAt", "uuid", "done"})

	return &UploadExec{ret}
}

func (instance ChunkExec) Exec(ctx context.Context) (*Chunk, error) {
	var v Chunk
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance ChunkExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type ChunkExecArray struct {
	exec *prisma.Exec
}

func (instance ChunkExecArray) Exec(ctx context.Context) ([]Chunk, error) {
	var v []Chunk
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type Chunk struct {
	ID         string `json:"id"`
	CreatedAt  string `json:"createdAt"`
	UpdatedAt  string `json:"updatedAt"`
	RangeStart *int32 `json:"rangeStart,omitempty"`
	RangeEnd   *int32 `json:"rangeEnd,omitempty"`
}

type UploadExec struct {
	exec *prisma.Exec
}

type ChunksParamsExec struct {
	Where   *ChunkWhereInput
	OrderBy *ChunkOrderByInput
	Skip    *int32
	After   *string
	Before  *string
	First   *int32
	Last    *int32
}

func (instance *UploadExec) Chunks(params *ChunksParamsExec) *ChunkExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := instance.exec.Client.GetMany(
		instance.exec,
		wparams,
		[3]string{"ChunkWhereInput", "ChunkOrderByInput", "Chunk"},
		"chunks",
		[]string{"id", "createdAt", "updatedAt", "rangeStart", "rangeEnd"})

	return &ChunkExecArray{ret}
}

func (instance UploadExec) Exec(ctx context.Context) (*Upload, error) {
	var v Upload
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance UploadExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type UploadExecArray struct {
	exec *prisma.Exec
}

func (instance UploadExecArray) Exec(ctx context.Context) ([]Upload, error) {
	var v []Upload
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type Upload struct {
	ID        string `json:"id"`
	CreatedAt string `json:"createdAt"`
	UpdatedAt string `json:"updatedAt"`
	Uuid      string `json:"uuid"`
	Done      bool   `json:"done"`
}

type ChunkConnectionExec struct {
	exec *prisma.Exec
}

func (instance *ChunkConnectionExec) PageInfo() *PageInfoExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PageInfo"},
		"pageInfo",
		[]string{"hasNextPage", "hasPreviousPage", "startCursor", "endCursor"})

	return &PageInfoExec{ret}
}

func (instance *ChunkConnectionExec) Edges() *ChunkEdgeExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "ChunkEdge"},
		"edges",
		[]string{"cursor"})

	return &ChunkEdgeExec{ret}
}

func (instance *ChunkConnectionExec) Aggregate(ctx context.Context) (Aggregate, error) {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AggregateChunk"},
		"aggregate",
		[]string{"count"})

	var v Aggregate
	_, err := ret.Exec(ctx, &v)
	return v, err
}

func (instance ChunkConnectionExec) Exec(ctx context.Context) (*ChunkConnection, error) {
	var v ChunkConnection
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance ChunkConnectionExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type ChunkConnectionExecArray struct {
	exec *prisma.Exec
}

func (instance ChunkConnectionExecArray) Exec(ctx context.Context) ([]ChunkConnection, error) {
	var v []ChunkConnection
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type ChunkConnection struct {
}

type ChunkEdgeExec struct {
	exec *prisma.Exec
}

func (instance *ChunkEdgeExec) Node() *ChunkExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Chunk"},
		"node",
		[]string{"id", "createdAt", "updatedAt", "rangeStart", "rangeEnd"})

	return &ChunkExec{ret}
}

func (instance ChunkEdgeExec) Exec(ctx context.Context) (*ChunkEdge, error) {
	var v ChunkEdge
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance ChunkEdgeExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type ChunkEdgeExecArray struct {
	exec *prisma.Exec
}

func (instance ChunkEdgeExecArray) Exec(ctx context.Context) ([]ChunkEdge, error) {
	var v []ChunkEdge
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type ChunkEdge struct {
	Cursor string `json:"cursor"`
}

type ImageConnectionExec struct {
	exec *prisma.Exec
}

func (instance *ImageConnectionExec) PageInfo() *PageInfoExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PageInfo"},
		"pageInfo",
		[]string{"hasNextPage", "hasPreviousPage", "startCursor", "endCursor"})

	return &PageInfoExec{ret}
}

func (instance *ImageConnectionExec) Edges() *ImageEdgeExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "ImageEdge"},
		"edges",
		[]string{"cursor"})

	return &ImageEdgeExec{ret}
}

func (instance *ImageConnectionExec) Aggregate(ctx context.Context) (Aggregate, error) {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AggregateImage"},
		"aggregate",
		[]string{"count"})

	var v Aggregate
	_, err := ret.Exec(ctx, &v)
	return v, err
}

func (instance ImageConnectionExec) Exec(ctx context.Context) (*ImageConnection, error) {
	var v ImageConnection
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance ImageConnectionExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type ImageConnectionExecArray struct {
	exec *prisma.Exec
}

func (instance ImageConnectionExecArray) Exec(ctx context.Context) ([]ImageConnection, error) {
	var v []ImageConnection
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type ImageConnection struct {
}

type ImageEdgeExec struct {
	exec *prisma.Exec
}

func (instance *ImageEdgeExec) Node() *ImageExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Image"},
		"node",
		[]string{"id", "createdAt", "updatedAt", "digest", "manifest", "manifest_type"})

	return &ImageExec{ret}
}

func (instance ImageEdgeExec) Exec(ctx context.Context) (*ImageEdge, error) {
	var v ImageEdge
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance ImageEdgeExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type ImageEdgeExecArray struct {
	exec *prisma.Exec
}

func (instance ImageEdgeExecArray) Exec(ctx context.Context) ([]ImageEdge, error) {
	var v []ImageEdge
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type ImageEdge struct {
	Cursor string `json:"cursor"`
}

type OrganizationConnectionExec struct {
	exec *prisma.Exec
}

func (instance *OrganizationConnectionExec) PageInfo() *PageInfoExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PageInfo"},
		"pageInfo",
		[]string{"hasNextPage", "hasPreviousPage", "startCursor", "endCursor"})

	return &PageInfoExec{ret}
}

func (instance *OrganizationConnectionExec) Edges() *OrganizationEdgeExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "OrganizationEdge"},
		"edges",
		[]string{"cursor"})

	return &OrganizationEdgeExec{ret}
}

func (instance *OrganizationConnectionExec) Aggregate(ctx context.Context) (Aggregate, error) {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AggregateOrganization"},
		"aggregate",
		[]string{"count"})

	var v Aggregate
	_, err := ret.Exec(ctx, &v)
	return v, err
}

func (instance OrganizationConnectionExec) Exec(ctx context.Context) (*OrganizationConnection, error) {
	var v OrganizationConnection
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance OrganizationConnectionExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type OrganizationConnectionExecArray struct {
	exec *prisma.Exec
}

func (instance OrganizationConnectionExecArray) Exec(ctx context.Context) ([]OrganizationConnection, error) {
	var v []OrganizationConnection
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type OrganizationConnection struct {
}

type OrganizationEdgeExec struct {
	exec *prisma.Exec
}

func (instance *OrganizationEdgeExec) Node() *OrganizationExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Organization"},
		"node",
		[]string{"id", "createdAt", "updatedAt", "name"})

	return &OrganizationExec{ret}
}

func (instance OrganizationEdgeExec) Exec(ctx context.Context) (*OrganizationEdge, error) {
	var v OrganizationEdge
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance OrganizationEdgeExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type OrganizationEdgeExecArray struct {
	exec *prisma.Exec
}

func (instance OrganizationEdgeExecArray) Exec(ctx context.Context) ([]OrganizationEdge, error) {
	var v []OrganizationEdge
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type OrganizationEdge struct {
	Cursor string `json:"cursor"`
}

type RepositoryConnectionExec struct {
	exec *prisma.Exec
}

func (instance *RepositoryConnectionExec) PageInfo() *PageInfoExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PageInfo"},
		"pageInfo",
		[]string{"hasNextPage", "hasPreviousPage", "startCursor", "endCursor"})

	return &PageInfoExec{ret}
}

func (instance *RepositoryConnectionExec) Edges() *RepositoryEdgeExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "RepositoryEdge"},
		"edges",
		[]string{"cursor"})

	return &RepositoryEdgeExec{ret}
}

func (instance *RepositoryConnectionExec) Aggregate(ctx context.Context) (Aggregate, error) {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AggregateRepository"},
		"aggregate",
		[]string{"count"})

	var v Aggregate
	_, err := ret.Exec(ctx, &v)
	return v, err
}

func (instance RepositoryConnectionExec) Exec(ctx context.Context) (*RepositoryConnection, error) {
	var v RepositoryConnection
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance RepositoryConnectionExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type RepositoryConnectionExecArray struct {
	exec *prisma.Exec
}

func (instance RepositoryConnectionExecArray) Exec(ctx context.Context) ([]RepositoryConnection, error) {
	var v []RepositoryConnection
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type RepositoryConnection struct {
}

type RepositoryEdgeExec struct {
	exec *prisma.Exec
}

func (instance *RepositoryEdgeExec) Node() *RepositoryExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Repository"},
		"node",
		[]string{"id", "createdAt", "updatedAt", "name"})

	return &RepositoryExec{ret}
}

func (instance RepositoryEdgeExec) Exec(ctx context.Context) (*RepositoryEdge, error) {
	var v RepositoryEdge
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance RepositoryEdgeExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type RepositoryEdgeExecArray struct {
	exec *prisma.Exec
}

func (instance RepositoryEdgeExecArray) Exec(ctx context.Context) ([]RepositoryEdge, error) {
	var v []RepositoryEdge
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type RepositoryEdge struct {
	Cursor string `json:"cursor"`
}

type TagConnectionExec struct {
	exec *prisma.Exec
}

func (instance *TagConnectionExec) PageInfo() *PageInfoExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PageInfo"},
		"pageInfo",
		[]string{"hasNextPage", "hasPreviousPage", "startCursor", "endCursor"})

	return &PageInfoExec{ret}
}

func (instance *TagConnectionExec) Edges() *TagEdgeExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "TagEdge"},
		"edges",
		[]string{"cursor"})

	return &TagEdgeExec{ret}
}

func (instance *TagConnectionExec) Aggregate(ctx context.Context) (Aggregate, error) {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AggregateTag"},
		"aggregate",
		[]string{"count"})

	var v Aggregate
	_, err := ret.Exec(ctx, &v)
	return v, err
}

func (instance TagConnectionExec) Exec(ctx context.Context) (*TagConnection, error) {
	var v TagConnection
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance TagConnectionExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type TagConnectionExecArray struct {
	exec *prisma.Exec
}

func (instance TagConnectionExecArray) Exec(ctx context.Context) ([]TagConnection, error) {
	var v []TagConnection
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type TagConnection struct {
}

type TagEdgeExec struct {
	exec *prisma.Exec
}

func (instance *TagEdgeExec) Node() *TagExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Tag"},
		"node",
		[]string{"id", "createdAt", "updatedAt"})

	return &TagExec{ret}
}

func (instance TagEdgeExec) Exec(ctx context.Context) (*TagEdge, error) {
	var v TagEdge
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance TagEdgeExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type TagEdgeExecArray struct {
	exec *prisma.Exec
}

func (instance TagEdgeExecArray) Exec(ctx context.Context) ([]TagEdge, error) {
	var v []TagEdge
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type TagEdge struct {
	Cursor string `json:"cursor"`
}

type UploadConnectionExec struct {
	exec *prisma.Exec
}

func (instance *UploadConnectionExec) PageInfo() *PageInfoExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PageInfo"},
		"pageInfo",
		[]string{"hasNextPage", "hasPreviousPage", "startCursor", "endCursor"})

	return &PageInfoExec{ret}
}

func (instance *UploadConnectionExec) Edges() *UploadEdgeExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "UploadEdge"},
		"edges",
		[]string{"cursor"})

	return &UploadEdgeExec{ret}
}

func (instance *UploadConnectionExec) Aggregate(ctx context.Context) (Aggregate, error) {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AggregateUpload"},
		"aggregate",
		[]string{"count"})

	var v Aggregate
	_, err := ret.Exec(ctx, &v)
	return v, err
}

func (instance UploadConnectionExec) Exec(ctx context.Context) (*UploadConnection, error) {
	var v UploadConnection
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance UploadConnectionExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type UploadConnectionExecArray struct {
	exec *prisma.Exec
}

func (instance UploadConnectionExecArray) Exec(ctx context.Context) ([]UploadConnection, error) {
	var v []UploadConnection
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type UploadConnection struct {
}

type UploadEdgeExec struct {
	exec *prisma.Exec
}

func (instance *UploadEdgeExec) Node() *UploadExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Upload"},
		"node",
		[]string{"id", "createdAt", "updatedAt", "uuid", "done"})

	return &UploadExec{ret}
}

func (instance UploadEdgeExec) Exec(ctx context.Context) (*UploadEdge, error) {
	var v UploadEdge
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance UploadEdgeExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type UploadEdgeExecArray struct {
	exec *prisma.Exec
}

func (instance UploadEdgeExecArray) Exec(ctx context.Context) ([]UploadEdge, error) {
	var v []UploadEdge
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type UploadEdge struct {
	Cursor string `json:"cursor"`
}

type BlobSubscriptionPayloadExec struct {
	exec *prisma.Exec
}

func (instance *BlobSubscriptionPayloadExec) Node() *BlobExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Blob"},
		"node",
		[]string{"id", "createdAt", "updatedAt", "digest"})

	return &BlobExec{ret}
}

func (instance *BlobSubscriptionPayloadExec) PreviousValues() *BlobPreviousValuesExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "BlobPreviousValues"},
		"previousValues",
		[]string{"id", "createdAt", "updatedAt", "digest"})

	return &BlobPreviousValuesExec{ret}
}

func (instance BlobSubscriptionPayloadExec) Exec(ctx context.Context) (*BlobSubscriptionPayload, error) {
	var v BlobSubscriptionPayload
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance BlobSubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type BlobSubscriptionPayloadExecArray struct {
	exec *prisma.Exec
}

func (instance BlobSubscriptionPayloadExecArray) Exec(ctx context.Context) ([]BlobSubscriptionPayload, error) {
	var v []BlobSubscriptionPayload
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type BlobSubscriptionPayload struct {
	Mutation      MutationType `json:"mutation"`
	UpdatedFields []string     `json:"updatedFields,omitempty"`
}

type BlobPreviousValuesExec struct {
	exec *prisma.Exec
}

func (instance BlobPreviousValuesExec) Exec(ctx context.Context) (*BlobPreviousValues, error) {
	var v BlobPreviousValues
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance BlobPreviousValuesExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type BlobPreviousValuesExecArray struct {
	exec *prisma.Exec
}

func (instance BlobPreviousValuesExecArray) Exec(ctx context.Context) ([]BlobPreviousValues, error) {
	var v []BlobPreviousValues
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type BlobPreviousValues struct {
	ID        string `json:"id"`
	CreatedAt string `json:"createdAt"`
	UpdatedAt string `json:"updatedAt"`
	Digest    string `json:"digest"`
}

type ChunkSubscriptionPayloadExec struct {
	exec *prisma.Exec
}

func (instance *ChunkSubscriptionPayloadExec) Node() *ChunkExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Chunk"},
		"node",
		[]string{"id", "createdAt", "updatedAt", "rangeStart", "rangeEnd"})

	return &ChunkExec{ret}
}

func (instance *ChunkSubscriptionPayloadExec) PreviousValues() *ChunkPreviousValuesExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "ChunkPreviousValues"},
		"previousValues",
		[]string{"id", "createdAt", "updatedAt", "rangeStart", "rangeEnd"})

	return &ChunkPreviousValuesExec{ret}
}

func (instance ChunkSubscriptionPayloadExec) Exec(ctx context.Context) (*ChunkSubscriptionPayload, error) {
	var v ChunkSubscriptionPayload
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance ChunkSubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type ChunkSubscriptionPayloadExecArray struct {
	exec *prisma.Exec
}

func (instance ChunkSubscriptionPayloadExecArray) Exec(ctx context.Context) ([]ChunkSubscriptionPayload, error) {
	var v []ChunkSubscriptionPayload
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type ChunkSubscriptionPayload struct {
	Mutation      MutationType `json:"mutation"`
	UpdatedFields []string     `json:"updatedFields,omitempty"`
}

type ChunkPreviousValuesExec struct {
	exec *prisma.Exec
}

func (instance ChunkPreviousValuesExec) Exec(ctx context.Context) (*ChunkPreviousValues, error) {
	var v ChunkPreviousValues
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance ChunkPreviousValuesExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type ChunkPreviousValuesExecArray struct {
	exec *prisma.Exec
}

func (instance ChunkPreviousValuesExecArray) Exec(ctx context.Context) ([]ChunkPreviousValues, error) {
	var v []ChunkPreviousValues
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type ChunkPreviousValues struct {
	ID         string `json:"id"`
	CreatedAt  string `json:"createdAt"`
	UpdatedAt  string `json:"updatedAt"`
	RangeStart *int32 `json:"rangeStart,omitempty"`
	RangeEnd   *int32 `json:"rangeEnd,omitempty"`
}

type ImageSubscriptionPayloadExec struct {
	exec *prisma.Exec
}

func (instance *ImageSubscriptionPayloadExec) Node() *ImageExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Image"},
		"node",
		[]string{"id", "createdAt", "updatedAt", "digest", "manifest", "manifest_type"})

	return &ImageExec{ret}
}

func (instance *ImageSubscriptionPayloadExec) PreviousValues() *ImagePreviousValuesExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "ImagePreviousValues"},
		"previousValues",
		[]string{"id", "createdAt", "updatedAt", "digest", "manifest", "manifest_type"})

	return &ImagePreviousValuesExec{ret}
}

func (instance ImageSubscriptionPayloadExec) Exec(ctx context.Context) (*ImageSubscriptionPayload, error) {
	var v ImageSubscriptionPayload
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance ImageSubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type ImageSubscriptionPayloadExecArray struct {
	exec *prisma.Exec
}

func (instance ImageSubscriptionPayloadExecArray) Exec(ctx context.Context) ([]ImageSubscriptionPayload, error) {
	var v []ImageSubscriptionPayload
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type ImageSubscriptionPayload struct {
	Mutation      MutationType `json:"mutation"`
	UpdatedFields []string     `json:"updatedFields,omitempty"`
}

type ImagePreviousValuesExec struct {
	exec *prisma.Exec
}

func (instance ImagePreviousValuesExec) Exec(ctx context.Context) (*ImagePreviousValues, error) {
	var v ImagePreviousValues
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance ImagePreviousValuesExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type ImagePreviousValuesExecArray struct {
	exec *prisma.Exec
}

func (instance ImagePreviousValuesExecArray) Exec(ctx context.Context) ([]ImagePreviousValues, error) {
	var v []ImagePreviousValues
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type ImagePreviousValues struct {
	ID           string                 `json:"id"`
	CreatedAt    string                 `json:"createdAt"`
	UpdatedAt    string                 `json:"updatedAt"`
	Digest       string                 `json:"digest"`
	Manifest     map[string]interface{} `json:"manifest"`
	ManifestType string                 `json:"manifest_type"`
}

type OrganizationSubscriptionPayloadExec struct {
	exec *prisma.Exec
}

func (instance *OrganizationSubscriptionPayloadExec) Node() *OrganizationExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Organization"},
		"node",
		[]string{"id", "createdAt", "updatedAt", "name"})

	return &OrganizationExec{ret}
}

func (instance *OrganizationSubscriptionPayloadExec) PreviousValues() *OrganizationPreviousValuesExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "OrganizationPreviousValues"},
		"previousValues",
		[]string{"id", "createdAt", "updatedAt", "name"})

	return &OrganizationPreviousValuesExec{ret}
}

func (instance OrganizationSubscriptionPayloadExec) Exec(ctx context.Context) (*OrganizationSubscriptionPayload, error) {
	var v OrganizationSubscriptionPayload
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance OrganizationSubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type OrganizationSubscriptionPayloadExecArray struct {
	exec *prisma.Exec
}

func (instance OrganizationSubscriptionPayloadExecArray) Exec(ctx context.Context) ([]OrganizationSubscriptionPayload, error) {
	var v []OrganizationSubscriptionPayload
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type OrganizationSubscriptionPayload struct {
	Mutation      MutationType `json:"mutation"`
	UpdatedFields []string     `json:"updatedFields,omitempty"`
}

type OrganizationPreviousValuesExec struct {
	exec *prisma.Exec
}

func (instance OrganizationPreviousValuesExec) Exec(ctx context.Context) (*OrganizationPreviousValues, error) {
	var v OrganizationPreviousValues
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance OrganizationPreviousValuesExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type OrganizationPreviousValuesExecArray struct {
	exec *prisma.Exec
}

func (instance OrganizationPreviousValuesExecArray) Exec(ctx context.Context) ([]OrganizationPreviousValues, error) {
	var v []OrganizationPreviousValues
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type OrganizationPreviousValues struct {
	ID        string `json:"id"`
	CreatedAt string `json:"createdAt"`
	UpdatedAt string `json:"updatedAt"`
	Name      string `json:"name"`
}

type RepositorySubscriptionPayloadExec struct {
	exec *prisma.Exec
}

func (instance *RepositorySubscriptionPayloadExec) Node() *RepositoryExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Repository"},
		"node",
		[]string{"id", "createdAt", "updatedAt", "name"})

	return &RepositoryExec{ret}
}

func (instance *RepositorySubscriptionPayloadExec) PreviousValues() *RepositoryPreviousValuesExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "RepositoryPreviousValues"},
		"previousValues",
		[]string{"id", "createdAt", "updatedAt", "name"})

	return &RepositoryPreviousValuesExec{ret}
}

func (instance RepositorySubscriptionPayloadExec) Exec(ctx context.Context) (*RepositorySubscriptionPayload, error) {
	var v RepositorySubscriptionPayload
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance RepositorySubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type RepositorySubscriptionPayloadExecArray struct {
	exec *prisma.Exec
}

func (instance RepositorySubscriptionPayloadExecArray) Exec(ctx context.Context) ([]RepositorySubscriptionPayload, error) {
	var v []RepositorySubscriptionPayload
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type RepositorySubscriptionPayload struct {
	Mutation      MutationType `json:"mutation"`
	UpdatedFields []string     `json:"updatedFields,omitempty"`
}

type RepositoryPreviousValuesExec struct {
	exec *prisma.Exec
}

func (instance RepositoryPreviousValuesExec) Exec(ctx context.Context) (*RepositoryPreviousValues, error) {
	var v RepositoryPreviousValues
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance RepositoryPreviousValuesExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type RepositoryPreviousValuesExecArray struct {
	exec *prisma.Exec
}

func (instance RepositoryPreviousValuesExecArray) Exec(ctx context.Context) ([]RepositoryPreviousValues, error) {
	var v []RepositoryPreviousValues
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type RepositoryPreviousValues struct {
	ID        string `json:"id"`
	CreatedAt string `json:"createdAt"`
	UpdatedAt string `json:"updatedAt"`
	Name      string `json:"name"`
}

type TagSubscriptionPayloadExec struct {
	exec *prisma.Exec
}

func (instance *TagSubscriptionPayloadExec) Node() *TagExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Tag"},
		"node",
		[]string{"id", "createdAt", "updatedAt"})

	return &TagExec{ret}
}

func (instance *TagSubscriptionPayloadExec) PreviousValues() *TagPreviousValuesExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "TagPreviousValues"},
		"previousValues",
		[]string{"id", "createdAt", "updatedAt"})

	return &TagPreviousValuesExec{ret}
}

func (instance TagSubscriptionPayloadExec) Exec(ctx context.Context) (*TagSubscriptionPayload, error) {
	var v TagSubscriptionPayload
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance TagSubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type TagSubscriptionPayloadExecArray struct {
	exec *prisma.Exec
}

func (instance TagSubscriptionPayloadExecArray) Exec(ctx context.Context) ([]TagSubscriptionPayload, error) {
	var v []TagSubscriptionPayload
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type TagSubscriptionPayload struct {
	Mutation      MutationType `json:"mutation"`
	UpdatedFields []string     `json:"updatedFields,omitempty"`
}

type TagPreviousValuesExec struct {
	exec *prisma.Exec
}

func (instance TagPreviousValuesExec) Exec(ctx context.Context) (*TagPreviousValues, error) {
	var v TagPreviousValues
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance TagPreviousValuesExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type TagPreviousValuesExecArray struct {
	exec *prisma.Exec
}

func (instance TagPreviousValuesExecArray) Exec(ctx context.Context) ([]TagPreviousValues, error) {
	var v []TagPreviousValues
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type TagPreviousValues struct {
	ID        string `json:"id"`
	CreatedAt string `json:"createdAt"`
	UpdatedAt string `json:"updatedAt"`
}

type UploadSubscriptionPayloadExec struct {
	exec *prisma.Exec
}

func (instance *UploadSubscriptionPayloadExec) Node() *UploadExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Upload"},
		"node",
		[]string{"id", "createdAt", "updatedAt", "uuid", "done"})

	return &UploadExec{ret}
}

func (instance *UploadSubscriptionPayloadExec) PreviousValues() *UploadPreviousValuesExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "UploadPreviousValues"},
		"previousValues",
		[]string{"id", "createdAt", "updatedAt", "uuid", "done"})

	return &UploadPreviousValuesExec{ret}
}

func (instance UploadSubscriptionPayloadExec) Exec(ctx context.Context) (*UploadSubscriptionPayload, error) {
	var v UploadSubscriptionPayload
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance UploadSubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type UploadSubscriptionPayloadExecArray struct {
	exec *prisma.Exec
}

func (instance UploadSubscriptionPayloadExecArray) Exec(ctx context.Context) ([]UploadSubscriptionPayload, error) {
	var v []UploadSubscriptionPayload
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type UploadSubscriptionPayload struct {
	Mutation      MutationType `json:"mutation"`
	UpdatedFields []string     `json:"updatedFields,omitempty"`
}

type UploadPreviousValuesExec struct {
	exec *prisma.Exec
}

func (instance UploadPreviousValuesExec) Exec(ctx context.Context) (*UploadPreviousValues, error) {
	var v UploadPreviousValues
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance UploadPreviousValuesExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type UploadPreviousValuesExecArray struct {
	exec *prisma.Exec
}

func (instance UploadPreviousValuesExecArray) Exec(ctx context.Context) ([]UploadPreviousValues, error) {
	var v []UploadPreviousValues
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type UploadPreviousValues struct {
	ID        string `json:"id"`
	CreatedAt string `json:"createdAt"`
	UpdatedAt string `json:"updatedAt"`
	Uuid      string `json:"uuid"`
	Done      bool   `json:"done"`
}
